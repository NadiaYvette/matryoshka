% design.tex — Matryoshka Tree Design Document
% Compile: pdflatex design.tex  (run twice for ToC/hyperref)

\documentclass[11pt,letterpaper]{article}

% ── Packages ──────────────────────────────────────────────────────
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{siunitx}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{float}
\usepackage{enumitem}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{listings}
\usepackage{tocloft}
\usepackage[font=small,labelfont=bf]{caption}

\usetikzlibrary{
  arrows.meta,
  positioning,
  decorations.brace,
  calc,
  fit,
  patterns,
  shapes.geometric,
  shapes.multipart,
  backgrounds,
  matrix
}

% ── Colors ────────────────────────────────────────────────────────
\definecolor{inodecolor}{HTML}{DBEAFE}    % light blue — internal nodes
\definecolor{leafcolor}{HTML}{D1FAE5}     % light green — leaf nodes
\definecolor{simdblk}{HTML}{FDE68A}       % gold — SIMD blocks
\definecolor{clblk}{HTML}{C4B5FD}         % violet — cache-line blocks
\definecolor{pageblk}{HTML}{FECACA}       % rose — page blocks
\definecolor{ptrcolor}{HTML}{3B82F6}      % blue — pointers
\definecolor{keycolor}{HTML}{1F2937}      % dark gray — keys
\definecolor{headercolor}{HTML}{F3F4F6}   % light gray — headers
\definecolor{rankcolor}{HTML}{A7F3D0}     % mint — sorted_rank
\definecolor{codebg}{HTML}{F8FAFC}

% ── Listings ──────────────────────────────────────────────────────
\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{codebg},
  frame=single,
  framerule=0.4pt,
  rulecolor=\color{gray!40},
  breaklines=true,
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  language=C,
  morekeywords={int32_t,int16_t,uint16_t,uint32_t,uint64_t,size_t,bool,
                __m128i,mt_inode_t,mt_lnode_t,mt_node_t},
}

% ── Page style ────────────────────────────────────────────────────
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Matryoshka Tree Design Document}
\fancyhead[R]{\small\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\hypersetup{
  colorlinks=true,
  linkcolor=blue!60!black,
  citecolor=blue!60!black,
  urlcolor=blue!60!black,
  pdfstartview=FitH,
}
\pdfstringdefDisableCommands{%
  \def\textsuperscript#1{+}%
}

% ── Convenience macros ────────────────────────────────────────────
\newcommand{\dk}{d_K}
\newcommand{\dl}{d_L}
\newcommand{\dpg}{d_P}
\newcommand{\dn}{d_N}
\newcommand{\nk}{N_K}
\newcommand{\nl}{N_L}
\newcommand{\np}{N_P}
\newcommand{\Oh}{\mathcal{O}}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\code}[1]{\texttt{#1}}

% ══════════════════════════════════════════════════════════════════
\begin{document}

\begin{titlepage}
\centering
\vspace*{2cm}
{\Huge\bfseries Matryoshka Trees\par}
\vspace{0.5cm}
{\Large\itshape A Modification-Friendly, Cache-Conscious\\ B\textsuperscript{+} Tree
  with SIMD-Blocked Nodes\par}
\vspace{2cm}
{\large Design Document\par}
\vspace{1cm}
{\large\today\par}
\vfill
{\small
This document describes the design of the \emph{matryoshka tree}, a B\textsuperscript{+}
tree variant that embeds FAST-style hierarchical blocking~\cite{kim2010fast} within
each leaf node while retaining the standard B\textsuperscript{+} tree's support for
efficient insertions, deletions, and range scans.  The name reflects the nested
(``Russian doll'') architecture: SIMD blocks nest inside cache-line blocks, which
nest inside page-sized B\textsuperscript{+} nodes, which compose the full tree.}
\end{titlepage}

\tableofcontents
\newpage

% ══════════════════════════════════════════════════════════════════
\section{Introduction}
\label{sec:intro}

The matryoshka tree addresses a long-standing tension in main-memory index
design: \emph{search throughput versus modification cost}.

On one end of the spectrum, the FAST tree~\cite{kim2010fast} achieves
near-optimal search throughput by mapping an implicit (pointerless)
search tree onto the memory hierarchy through a recursive blocking
scheme.  Each level of the blocking matches a level of the hardware:
SSE registers (\SI{16}{\byte}), cache lines (\SI{64}{\byte}), pages
(\SI{4}{\kilo\byte}), and superpages (\SI{2}{\mebi\byte}).  Because the
layout is implicit (positions are computed arithmetically, not followed
via pointers), it eliminates pointer-chasing stalls and maximises
hardware prefetch effectiveness.  The price is that any structural
modification---insertion or deletion---requires a full $\Oh(n)$ rebuild.

On the other end, classical B\textsuperscript{+}
trees~\cite{bayer1972organization,comer1979ubiquitous} support
$\Oh(\log_B n)$ modifications via node-local splits and merges, but
suffer from pointer-chasing at every level of the tree, causing a TLB
miss and often an L2/L3 cache miss per node visited.

The matryoshka tree reconciles these by restricting FAST-style blocking
to \emph{within} each B\textsuperscript{+} node (specifically, within
leaf nodes), and using standard pointer-based navigation \emph{between}
nodes.  The result is:

\begin{itemize}[nosep]
  \item \textbf{Fast intra-node search}: Each leaf contains up to 511
    keys in a FAST-blocked layout, searched via SIMD in
    $\ceil{\dn/\dk}$ SSE operations, where $\dn$ is the tree depth
    within the leaf and $\dk = 2$ is the SIMD block depth.
  \item \textbf{Efficient modifications}: Insertions and deletions
    rebuild only the affected leaf ($\Oh(B)$ work) and propagate splits
    or merges up $\Oh(\log_B n)$ internal levels, for overall
    $\Oh(B \cdot \log_B n)$ cost.
  \item \textbf{Range scans}: A doubly-linked leaf list supports
    efficient sequential iteration across leaves.
\end{itemize}

\noindent
The name ``matryoshka'' reflects the nested architecture:

\begin{center}
\begin{tikzpicture}[
  every node/.style={draw, rounded corners=3pt, minimum height=1.3cm,
                     text width=5cm, align=center, font=\small},
  level1/.style={fill=simdblk!70},
  level2/.style={fill=clblk!50},
  level3/.style={fill=leafcolor!80},
  level4/.style={fill=inodecolor!60},
  >=stealth
]
  % Outermost: B+ tree
  \node[level4, minimum height=5.8cm, text width=12cm,
        label={[font=\footnotesize\bfseries]above:Level 4: B\textsuperscript{+} Tree (Main Memory)}]
    (bptree) {};

  % Page-level: B+ node
  \node[level3, minimum height=4.0cm, text width=9.5cm,
        label={[font=\footnotesize\bfseries]above:Level 2: B\textsuperscript{+} Leaf Node (\SI{4}{\kilo\byte} Page)}]
    at (bptree.center) (page) {};

  % Cache-line level
  \node[level2, minimum height=2.2cm, text width=6.5cm,
        label={[font=\footnotesize\bfseries]above:Level 1: Cache-Line Block (\SI{64}{\byte}, 15 keys)}]
    at (page.center) (clblock) {};

  % SIMD level
  \node[level1, minimum height=1.0cm, text width=3.5cm,
        label={[font=\footnotesize\bfseries]above:Level 0: SIMD Block (\SI{16}{\byte}, 3 keys)}]
    at (clblock.center) (simd) {$k_0\;\; k_1\;\; k_2$};

\end{tikzpicture}
\captionof{figure}{%
  \textbf{Nested blocking hierarchy.}
  The matryoshka architecture nests SIMD register--sized blocks
  (\textbf{Level~0}, gold) inside cache-line--sized blocks
  (\textbf{Level~1}, violet), which reside inside page-sized
  B\textsuperscript{+} leaf nodes (\textbf{Level~2}, green),
  composing the full B\textsuperscript{+} tree (\textbf{Level~4}, blue).
  Within each nesting level, navigation uses offset arithmetic
  (no pointers); between B\textsuperscript{+} nodes, navigation
  uses explicit child pointers.}
\label{fig:nesting}
\end{center}


% ══════════════════════════════════════════════════════════════════
\section{Related Work}
\label{sec:related}

The matryoshka tree draws from several lines of research in cache-conscious
indexing.  We situate it within the literature below.

\paragraph{B-trees and B\textsuperscript{+} trees.}
Bayer and McCreight~\cite{bayer1972organization} introduced the B-tree as a
balanced, external-memory search tree with $\Oh(\log_B n)$ search and
modification costs.  The B\textsuperscript{+} tree variant, formalized in
surveys by Comer~\cite{comer1979ubiquitous} and later by
Graefe~\cite{graefe2011modern}, stores all data in leaf nodes connected by a
linked list, with internal nodes serving purely as a routing index.  This
separation enables efficient range scans and simplifies concurrency
control~\cite{lehman1981efficient}.

\paragraph{Cache-sensitive search trees (CSS-trees).}
Rao and Ross~\cite{rao1999cache} observed that the pointer overhead in
B\textsuperscript{+} trees wastes cache space and proposed \emph{CSS-trees}:
implicit directory levels stored in sorted arrays, with child offsets computed
arithmetically.  This eliminates pointers within the directory, improving cache
utilization.  However, CSS-trees are static (read-only after bulk construction).

\paragraph{Cache-conscious B\textsuperscript{+} trees (CSB\textsuperscript{+}-trees).}
Rao and Ross~\cite{rao2000making} extended their cache-conscious approach to
support modifications by storing child nodes of each internal node in a
contiguous array, so a single pointer suffices per node (plus an offset).
This halves pointer storage compared to standard B\textsuperscript{+} trees.
Hankins and Patel~\cite{hankins2003effect} subsequently showed that the
optimal node size for cache-conscious B\textsuperscript{+} trees is
typically the cache-line size or a small multiple thereof, depending on the
access pattern.

\paragraph{SIMD-accelerated search.}
Zhou and Ross~\cite{zhou2002implementing} demonstrated that SIMD instructions
(specifically SSE2's \code{\_mm\_cmpgt\_epi32}) could accelerate database
operations including sorted-array search, achieving 4$\times$ parallelism per
comparison.  Schlegel et al.~\cite{schlegel2009kary} generalized this to
$k$-ary search on modern processors, showing that $k = 2^{\dk}$ simultaneous
comparisons reduce tree depth by a factor of $\dk$ relative to binary search.

\paragraph{FAST: Fast Architecture Sensitive Tree.}
Kim et al.~\cite{kim2010fast} combined hierarchical blocking with SIMD
comparisons to build a static index that maps directly onto the memory hierarchy.
The FAST tree defines blocking depths $\dk$ (SIMD register), $\dl$ (cache line),
and $\dpg$ (page/superpage) such that each block fits exactly in the
corresponding hardware unit.  Within each block, keys are stored in BFS
(breadth-first search) order of a complete binary tree, enabling SIMD-parallel
comparisons at each level.  The FAST tree achieves throughput within a factor of
two of a hardware-optimal binary search, but requires $\Oh(n)$ reconstruction
for any modification.

\paragraph{Masstree.}
Mao et al.~\cite{mao2012cache} built Masstree, a trie of B\textsuperscript{+}
trees designed for concurrent multicore key-value stores.  Each
B\textsuperscript{+} tree level handles a fixed-width slice of the key,
amortizing cache misses across key bytes.  Masstree uses optimistic concurrency
(version numbers per node) rather than locking, achieving high throughput under
contention.  Like the matryoshka tree, Masstree nests simpler structures inside
larger ones, though it uses a trie/B-tree nesting rather than FAST/B-tree.

\paragraph{Adaptive Radix Tree (ART).}
Leis et al.~\cite{leis2013adaptive} proposed ART, which adaptively selects
among four node sizes (4, 16, 48, 256 children) to balance space and search
efficiency.  ART uses SIMD for its smallest node type (Node16, using
\code{\_mm\_cmpeq\_epi8} for 16-way key matching).  While ART excels for
variable-length string keys, the matryoshka tree targets fixed-size integer
keys where FAST-style blocking is most effective.

\paragraph{Positioning of the matryoshka tree.}
The matryoshka tree occupies a specific niche: it provides the FAST tree's
intra-node search efficiency while supporting B\textsuperscript{+}-tree-style
modifications.  Table~\ref{tab:comparison} summarises the trade-offs.

\begin{table}[H]
\centering
\caption{\textbf{Comparison of index structures for sorted integer keys.}
  $n$ = number of keys, $B$ = node capacity, $\dk$ = SIMD block depth.}
\label{tab:comparison}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Structure} & \textbf{Search} & \textbf{Insert/Delete} & \textbf{Range Scan} & \textbf{SIMD} \\
\midrule
B\textsuperscript{+}-tree~\cite{bayer1972organization}
  & $\Oh(\log_B n)$ & $\Oh(\log_B n)$ & linked list & no \\
CSS-tree~\cite{rao1999cache}
  & $\Oh(\log_2 n)$ & $\Oh(n)$ rebuild & scan & no \\
CSB\textsuperscript{+}-tree~\cite{rao2000making}
  & $\Oh(\log_B n)$ & $\Oh(\log_B n)$ & linked list & no \\
FAST~\cite{kim2010fast}
  & $\Oh(\log_2 n / \dk)$ & $\Oh(n)$ rebuild & scan & yes \\
ART~\cite{leis2013adaptive}
  & $\Oh(k)$ depth & $\Oh(k)$ depth & DFS & partial \\
Masstree~\cite{mao2012cache}
  & $\Oh(k/w \cdot \log_B n)$ & $\Oh(k/w \cdot \log_B n)$ & linked list & no \\
\textbf{Matryoshka}
  & $\Oh(\log_B n \cdot \dn/\dk)$ & $\Oh(B \cdot \log_B n)$ & linked list & yes \\
\bottomrule
\end{tabular}
\end{table}


% ══════════════════════════════════════════════════════════════════
\section{Architecture Overview}
\label{sec:architecture}

A matryoshka tree is a B\textsuperscript{+} tree with two node types:

\begin{description}[leftmargin=2em, labelindent=0em]
  \item[Internal nodes] store sorted keys and child pointers in a
    conventional B\textsuperscript{+} layout.  Intra-node search uses
    SIMD-accelerated linear scan (for small fanout) or binary search
    (for large fanout).  Each internal node fits in one \SI{4}{\kilo\byte}
    page, holding up to 339 keys and 340 child pointers.

  \item[Leaf nodes] store keys in a FAST-style hierarchically blocked
    layout.  Each leaf fits in one \SI{4}{\kilo\byte} page, holding up
    to 511 keys.  Leaves are doubly linked for range scans.
\end{description}

Figure~\ref{fig:tree-structure} shows the overall tree structure.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  inode/.style={
    draw, fill=inodecolor, rounded corners=2pt,
    minimum width=5.5cm, minimum height=1.2cm,
    font=\small
  },
  leaf/.style={
    draw, fill=leafcolor, rounded corners=2pt,
    minimum width=3.2cm, minimum height=1.6cm,
    font=\small, align=center
  },
  ptr/.style={-{Stealth[length=5pt]}, thick, ptrcolor},
  leaflink/.style={-{Stealth[length=4pt]}, thick, red!60!black, densely dashed},
  lbl/.style={font=\scriptsize\itshape, text=gray!70!black}
]

  % ── Root internal node ──
  \node[inode] (root) {%
    \begin{tabular}{c@{\hskip 6pt}|@{\hskip 6pt}c@{\hskip 6pt}|@{\hskip 6pt}c}
      $p_0$ & $k_1{=}500$ & $p_1$ \\
      \hline
      & $k_2{=}1000$ & $p_2$ \\
    \end{tabular}
  };
  \node[lbl, above=2pt of root] {$I_0$ (root internal node)};

  % ── Child internal nodes ──
  \node[inode, below left=1.8cm and 1.5cm of root] (i1) {%
    \begin{tabular}{c@{\hskip 4pt}|@{\hskip 4pt}c@{\hskip 4pt}|@{\hskip 4pt}c@{\hskip 4pt}|@{\hskip 4pt}c}
      $p_0$ & $k_1{=}125$ & $p_1$ & $k_2{=}250$ \\
      \hline
      & & $p_2$ & \\
    \end{tabular}
  };
  \node[lbl, above=2pt of i1] {$I_1$};

  \node[inode, below right=1.8cm and 1.5cm of root] (i2) {%
    \begin{tabular}{c@{\hskip 4pt}|@{\hskip 4pt}c@{\hskip 4pt}|@{\hskip 4pt}c@{\hskip 4pt}|@{\hskip 4pt}c}
      $p_0$ & $k_1{=}625$ & $p_1$ & $k_2{=}750$ \\
      \hline
      & & $p_2$ & \\
    \end{tabular}
  };
  \node[lbl, above=2pt of i2] {$I_2$};

  % ── Leaf nodes ──
  \node[leaf, below=2.0cm of i1, xshift=-3.0cm] (l0)
    {$L_0$\\[-2pt]{\scriptsize keys $< 125$}\\[-2pt]{\scriptsize FAST layout}};
  \node[leaf, right=0.4cm of l0] (l1)
    {$L_1$\\[-2pt]{\scriptsize $[125, 250)$}\\[-2pt]{\scriptsize FAST layout}};
  \node[leaf, right=0.4cm of l1] (l2)
    {$L_2$\\[-2pt]{\scriptsize $[250, 500)$}\\[-2pt]{\scriptsize FAST layout}};
  \node[leaf, right=0.4cm of l2] (l3)
    {$L_3$\\[-2pt]{\scriptsize $[500, 625)$}\\[-2pt]{\scriptsize FAST layout}};
  \node[leaf, right=0.4cm of l3] (l4)
    {$L_4$\\[-2pt]{\scriptsize $[625, 750)$}\\[-2pt]{\scriptsize FAST layout}};
  \node[leaf, right=0.4cm of l4] (l5)
    {$L_5$\\[-2pt]{\scriptsize $\geq 750$}\\[-2pt]{\scriptsize FAST layout}};

  % ── Pointers: root → children ──
  \draw[ptr] (root.south west) ++(0.8cm, 0) -- (i1.north) node[midway, lbl, left] {$p_0$};
  \draw[ptr] (root.south) -- ++(0,-0.3cm) -| (i2.north) node[near start, lbl, right] {$p_1$};
  % p2 goes somewhere off to the right, but for simplicity we omit extra internal nodes

  % ── Pointers: I1 → leaves ──
  \draw[ptr] (i1.south) ++(-1.0cm, 0) -- (l0.north) node[midway, lbl, left=1pt] {$p_0$};
  \draw[ptr] (i1.south) -- (l1.north) node[midway, lbl, right=1pt] {$p_1$};
  \draw[ptr] (i1.south) ++(1.0cm, 0) -- (l2.north) node[midway, lbl, right=1pt] {$p_2$};

  % ── Pointers: I2 → leaves ──
  \draw[ptr] (i2.south) ++(-1.0cm, 0) -- (l3.north) node[midway, lbl, left=1pt] {$p_0$};
  \draw[ptr] (i2.south) -- (l4.north) node[midway, lbl, right=1pt] {$p_1$};
  \draw[ptr] (i2.south) ++(1.0cm, 0) -- (l5.north) node[midway, lbl, right=1pt] {$p_2$};

  % ── Leaf linked list ──
  \draw[leaflink] (l0.east) ++(0, -0.25cm) -- (l1.west |- l0.east) ++(0, -0.25cm)
    node[midway, lbl, above=1pt] {\code{next}};
  \draw[leaflink] (l1.east) ++(0, -0.25cm) -- (l2.west |- l1.east) ++(0, -0.25cm);
  \draw[leaflink] (l2.east) ++(0, -0.25cm) -- (l3.west |- l2.east) ++(0, -0.25cm);
  \draw[leaflink] (l3.east) ++(0, -0.25cm) -- (l4.west |- l3.east) ++(0, -0.25cm);
  \draw[leaflink] (l4.east) ++(0, -0.25cm) -- (l5.west |- l4.east) ++(0, -0.25cm);

  % ── prev pointers ──
  \draw[leaflink] (l1.west) ++(0, 0.25cm) -- (l0.east |- l1.west) ++(0, 0.25cm)
    node[midway, lbl, below=1pt] {\code{prev}};

  % ── Brace labels ──
  \draw[decorate, decoration={brace, amplitude=5pt, mirror}]
    (l0.south west) ++(0,-0.2cm) -- (l5.south east |- l0.south west) ++(0,-0.2cm)
    node[midway, below=8pt, font=\small\itshape] {Doubly-linked leaf chain (range scan order)};

\end{tikzpicture}
\caption{\textbf{Overall matryoshka tree structure.}
  Internal nodes $I_0$--$I_2$ (blue) contain sorted separator keys
  ($k_1$, $k_2$) and child pointers ($p_0$, $p_1$, $p_2$).
  Leaf nodes $L_0$--$L_5$ (green) contain FAST-blocked key layouts.
  Red dashed arrows show the doubly-linked leaf list (\code{next}/\code{prev}
  pointers) used for range scans.
  Blue solid arrows show child pointers followed during top-down search.
  The tree has height~2: two internal levels, one leaf level.}
\label{fig:tree-structure}
\end{figure}


% ══════════════════════════════════════════════════════════════════
\section{Node Structures}
\label{sec:nodes}

Both node types are allocated as page-aligned \SI{4}{\kilo\byte} buffers
via \code{posix\_memalign}.  This alignment ensures that each node
occupies exactly one virtual memory page, minimising TLB pressure during
tree traversal.

% ── Internal Node ─────────────────────────────────────────────────
\subsection{Internal Node (\code{mt\_inode\_t})}
\label{sec:inode}

Internal nodes store sorted keys and child pointers in a conventional
B\textsuperscript{+} layout:

\begin{equation}
  \underbrace{p_0}_{\text{child}_0} \;
  k_1 \;
  \underbrace{p_1}_{\text{child}_1} \;
  k_2 \;
  \underbrace{p_2}_{\text{child}_2} \;
  \cdots \;
  k_m \;
  \underbrace{p_m}_{\text{child}_m}
\label{eq:inode-layout}
\end{equation}

where $k_1 < k_2 < \cdots < k_m$ are separator keys, and child pointer
$p_i$ leads to the subtree containing keys in the range $[k_i, k_{i+1})$
(with $p_0$ covering $(-\infty, k_1)$ and $p_m$ covering $[k_m, +\infty)$).

The maximum number of keys per internal node is determined by the page
budget:
\begin{equation}
  \underbrace{16}_{\text{header}} + 4m + 8(m+1) \le 4096
  \quad\Longrightarrow\quad
  m \le 339
\label{eq:inode-capacity}
\end{equation}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  box/.style={draw, minimum height=0.8cm, font=\footnotesize, anchor=west},
  lbl/.style={font=\scriptsize, text=gray!60!black},
  brace/.style={decorate, decoration={brace, amplitude=4pt}},
]
  % Header
  \node[box, fill=headercolor, minimum width=1.0cm] (type) at (0,0) {\code{type}};
  \node[box, fill=headercolor, minimum width=1.0cm, right=0pt of type] (nkeys) {\code{nkeys}};
  \node[box, fill=headercolor, minimum width=1.0cm, right=0pt of nkeys] (pad) {\code{pad}};
  \node[box, fill=headercolor, minimum width=1.0cm, right=0pt of pad] (rsv) {\code{rsv}};

  % Keys
  \node[box, fill=simdblk!50, minimum width=6.0cm, right=0.3cm of rsv] (keys)
    {$k_0 \;\; k_1 \;\; k_2 \;\; \cdots \;\; k_{338}$ \quad (339 $\times$ \SI{4}{\byte} = \SI{1356}{\byte})};

  % Children
  \node[box, fill=ptrcolor!20, minimum width=5.5cm, right=0.3cm of keys] (children)
    {$p_0 \;\; p_1 \;\; \cdots \;\; p_{339}$ \quad (340 $\times$ \SI{8}{\byte} = \SI{2720}{\byte})};

  % Byte offsets
  \node[lbl, below=2pt of type.south west, anchor=north west] {0};
  \node[lbl, below=2pt of keys.south west, anchor=north west] {16};
  \node[lbl, below=2pt of children.south west, anchor=north west] {1372};
  \node[lbl, below=2pt of children.south east, anchor=north east] {4092};

  % Labels
  \node[lbl, above=2pt of type.north west, anchor=south west] {Header (\SI{16}{\byte})};
  \node[lbl, above=2pt of keys.north, anchor=south] {Sorted keys (\SI{1356}{\byte})};
  \node[lbl, above=2pt of children.north, anchor=south] {Child pointers (\SI{2720}{\byte})};

  % Page boundary
  \draw[thick, red!60!black, dashed]
    ([xshift=0.3cm]children.north east) -- ([xshift=0.3cm]children.south east)
    node[right, lbl, red!60!black] {\SI{4096}{\byte}};
\end{tikzpicture}
\caption{\textbf{Internal node (\code{mt\_inode\_t}) memory layout.}
  The header (gray, \SI{16}{\byte}) contains the node type discriminant
  (\code{type}=\code{MT\_NODE\_INTERNAL}), key count (\code{nkeys}),
  and padding.  The sorted key array (gold) holds up to 339 \code{int32\_t}
  keys.  The child pointer array (blue) holds up to 340 \code{mt\_node\_t*}
  pointers.  Total: $16 + 1356 + 2720 = 4092$ bytes, fitting within one
  \SI{4}{\kilo\byte} page.}
\label{fig:inode-layout}
\end{figure}

\paragraph{Internal node search.}
For nodes with $\le 32$ keys, \code{mt\_inode\_search} uses SIMD-accelerated
linear scan: it loads 4 keys per iteration into an SSE register
via \code{\_mm\_loadu\_si128}, compares all 4 against the broadcast query key
using \code{\_mm\_cmpgt\_epi32}, and extracts the first hit via
\code{\_mm\_movemask\_ps} and \code{\_\_builtin\_ctz}.  For larger nodes (up to
339 keys), it falls back to scalar binary search.  The result is the child
index~$i$ such that $k_{i-1} \le \mathit{key} < k_i$, which directly indexes
into the \code{children[]} array.

% ── Leaf Node ─────────────────────────────────────────────────────
\subsection{Leaf Node (\code{mt\_lnode\_t})}
\label{sec:lnode}

Leaf nodes use a FAST-style blocked layout rather than a simple sorted
array.  The leaf stores two parallel arrays:

\begin{itemize}[nosep]
  \item \code{layout[512]} (\code{int32\_t}): Keys in FAST-blocked
    (hierarchically BFS-ordered) positions.
  \item \code{sorted\_rank[512]} (\code{int16\_t}): For each position~$i$,
    \code{sorted\_rank[$i$]} gives the index that \code{layout[$i$]}
    would have in the sorted key sequence.
\end{itemize}

The \code{sorted\_rank} array serves as the bridge between the
cache-efficient blocked layout (optimised for search) and the logical
sorted order (needed for predecessor resolution and key extraction).

The page budget for a leaf is:
\begin{equation}
  \underbrace{24}_{\text{header}} + \underbrace{512 \times 4}_{\code{layout}} + \underbrace{512 \times 2}_{\code{sorted\_rank}} = 3096 \le 4096
\label{eq:lnode-size}
\end{equation}

The maximum tree depth within a leaf is $d = 9$ (since $2^9 - 1 = 511$ nodes),
giving a maximum key capacity of \textbf{511 keys per leaf}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  box/.style={draw, minimum height=0.8cm, font=\footnotesize, anchor=west},
  lbl/.style={font=\scriptsize, text=gray!60!black},
]
  % Header fields
  \node[box, fill=headercolor, minimum width=0.7cm] (type) at (0,0) {\tiny\code{type}};
  \node[box, fill=headercolor, minimum width=0.7cm, right=0pt of type] (nk) {\tiny\code{nkeys}};
  \node[box, fill=headercolor, minimum width=0.7cm, right=0pt of nk] (td) {\tiny\code{depth}};
  \node[box, fill=headercolor, minimum width=0.5cm, right=0pt of td] (pd) {\tiny\code{pad}};
  \node[box, fill=ptrcolor!20, minimum width=1.2cm, right=0pt of pd] (prev) {\tiny\code{*prev}};
  \node[box, fill=ptrcolor!20, minimum width=1.2cm, right=0pt of prev] (next) {\tiny\code{*next}};

  % Layout array
  \node[box, fill=simdblk!50, minimum width=5.5cm, right=0.3cm of next] (layout)
    {\code{layout[0..511]} \quad (512 $\times$ \SI{4}{\byte} = \SI{2048}{\byte})};

  % sorted_rank array
  \node[box, fill=rankcolor, minimum width=3.8cm, right=0.3cm of layout] (rank)
    {\code{sorted\_rank[0..511]} \quad (512 $\times$ \SI{2}{\byte} = \SI{1024}{\byte})};

  % Byte offsets
  \node[lbl, below=2pt of type.south west, anchor=north west] {0};
  \node[lbl, below=2pt of layout.south west, anchor=north west] {24};
  \node[lbl, below=2pt of rank.south west, anchor=north west] {2072};
  \node[lbl, below=2pt of rank.south east, anchor=north east] {3096};

  % Section labels
  \node[lbl, above=2pt of type.north west, anchor=south west] {Header (\SI{24}{\byte})};
  \node[lbl, above=2pt of layout.north, anchor=south] {FAST-blocked keys (\SI{2048}{\byte})};
  \node[lbl, above=2pt of rank.north, anchor=south] {Rank map (\SI{1024}{\byte})};

  % Page boundary
  \draw[thick, red!60!black, dashed]
    ([xshift=2.0cm]rank.north east) -- ([xshift=2.0cm]rank.south east)
    node[right, lbl, red!60!black] {\SI{4096}{\byte} page};

  % Free space
  \draw[thick, pattern=north west lines, pattern color=gray!30]
    ([xshift=0.05cm]rank.north east) rectangle ([xshift=1.95cm]rank.south east);
  \node[lbl] at ([xshift=1.0cm]rank.east) {free};
\end{tikzpicture}
\caption{\textbf{Leaf node (\code{mt\_lnode\_t}) memory layout.}
  The header (gray, \SI{24}{\byte}) contains the type discriminant,
  key count, tree depth, padding, and doubly-linked list pointers
  \code{*prev}/\code{*next} (blue).  The FAST-blocked key array
  (gold, \SI{2048}{\byte}) stores keys in hierarchically blocked BFS order.
  The rank map (mint, \SI{1024}{\byte}) maps each layout position to its
  index in sorted order.  Total payload: \SI{3096}{\byte}; remaining
  \SI{1000}{\byte} within the \SI{4}{\kilo\byte} page is unused.}
\label{fig:lnode-layout}
\end{figure}


% ══════════════════════════════════════════════════════════════════
\section{FAST Blocking within Leaf Nodes}
\label{sec:fast-blocking}

This section describes how keys within a single leaf node are arranged in
the FAST hierarchically blocked layout, following the scheme of Kim et
al.~\cite{kim2010fast}.

\subsection{Background: Complete Binary Search Trees in BFS Order}
\label{sec:bfs-tree}

Given $n$ sorted keys $k_0 < k_1 < \cdots < k_{n-1}$, we first embed them
into a complete binary search tree.  The tree has depth
$\dn = \ceil{\log_2(n+1)}$ and $2^{\dn}-1$ nodes (padding unused positions
with $+\infty$).

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  tnode/.style={circle, draw, minimum size=0.7cm, font=\footnotesize,
                inner sep=1pt},
  edge from parent/.style={draw, -{Stealth[length=4pt]}},
  level 1/.style={sibling distance=4.5cm, level distance=1.2cm},
  level 2/.style={sibling distance=2.2cm, level distance=1.2cm},
  level 3/.style={sibling distance=1.1cm, level distance=1.2cm},
  lbl/.style={font=\scriptsize\itshape, text=gray!60!black},
]
  \node[tnode, fill=simdblk!70] (r) {$k_3$}
    [child anchor=north, parent anchor=south]
    child { node[tnode, fill=simdblk!70] (n1) {$k_1$}
      child { node[tnode, fill=simdblk!70] (n3) {$k_0$}
        child[missing]
        child[missing]
      }
      child { node[tnode, fill=simdblk!70] (n4) {$k_2$}
        child[missing]
        child[missing]
      }
    }
    child { node[tnode, fill=simdblk!70] (n2) {$k_5$}
      child { node[tnode, fill=simdblk!70] (n5) {$k_4$}
        child[missing]
        child[missing]
      }
      child { node[tnode, fill=simdblk!70] (n6) {$k_6$}
        child[missing]
        child[missing]
      }
    };

  % BFS indices
  \node[lbl, above right=1pt and 3pt of r] {bfs[0]};
  \node[lbl, above left=1pt and 3pt of n1] {bfs[1]};
  \node[lbl, above right=1pt and 3pt of n2] {bfs[2]};
  \node[lbl, left=3pt of n3] {bfs[3]};
  \node[lbl, right=3pt of n4] {bfs[4]};
  \node[lbl, left=3pt of n5] {bfs[5]};
  \node[lbl, right=3pt of n6] {bfs[6]};

  % Depth labels
  \draw[gray, dashed] (-5.5, 0) -- (5.5, 0) node[right, lbl] {depth 0};
  \draw[gray, dashed] (-5.5, -1.2) -- (5.5, -1.2) node[right, lbl] {depth 1};
  \draw[gray, dashed] (-5.5, -2.4) -- (5.5, -2.4) node[right, lbl] {depth 2};

\end{tikzpicture}
\caption{\textbf{Complete binary search tree with 7 keys in BFS order.}
  Sorted keys $k_0 < k_1 < \cdots < k_6$ are placed so that an in-order
  traversal recovers the sorted sequence.  Each node is labelled with its
  BFS index (bfs[0] through bfs[6]).  The root at bfs[0] holds the
  median key $k_3$; left children hold smaller keys, right children hold
  larger keys.  The \code{bfs\_to\_sorted} mapping gives: bfs[0]$\to$3,
  bfs[1]$\to$1, bfs[2]$\to$5, bfs[3]$\to$0, bfs[4]$\to$2, bfs[5]$\to$4,
  bfs[6]$\to$6.}
\label{fig:bfs-tree}
\end{figure}

A standard BFS array stores the tree nodes level by level: the root at
index~0, its children at indices~1 and~2, their children at indices~3--6,
etc.  For a node at BFS index~$i$, its left child is at $2i+1$ and its
right child at $2i+2$.

\subsection{Hierarchical Blocking}
\label{sec:blocking}

Storing keys in plain BFS order does not respect the memory hierarchy:
for deep trees, a root-to-leaf traversal touches nodes scattered across
many cache lines.  FAST solves this by \emph{hierarchically blocking}
the BFS tree into nested subtrees, each sized to fit a hardware unit.

The blocking is defined by a sequence of depths:

\begin{center}
\begin{tabular}{@{}clll@{}}
\toprule
\textbf{Level} & \textbf{Depth} & \textbf{Keys per block} & \textbf{Hardware target} \\
\midrule
0 & $\dk = 2$ & $\nk = 2^{\dk}-1 = 3$ keys (\SI{12}{\byte}) & SSE register (\SI{16}{\byte}) \\
1 & $\dl = 4$ & $\nl = 2^{\dl}-1 = 15$ keys (\SI{60}{\byte}) & Cache line (\SI{64}{\byte}) \\
2 & $\dpg$    & $\np = 2^{\dpg}-1$ keys & Page / Superpage \\
\bottomrule
\end{tabular}
\end{center}

In the current matryoshka implementation, only SIMD-level blocking
($\dk = 2$) is used within leaf nodes.  The entire leaf tree is
decomposed into SIMD blocks of 3 keys each.  Cache-line blocking
($\dl = 4$) is deferred to a future optimisation---it requires matching
changes to the search-side traversal code.

\subsection{SIMD Block Layout}
\label{sec:simd-block}

Each SIMD block is a complete binary tree of depth $\dk = 2$, containing
$\nk = 3$ keys.  The keys within a block are stored in BFS order:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  snode/.style={circle, draw, thick, minimum size=0.65cm, font=\footnotesize,
                fill=simdblk!80, inner sep=0pt},
  edge from parent/.style={draw, thick, -{Stealth[length=4pt]}},
  level 1/.style={sibling distance=2.0cm, level distance=1.0cm},
  lbl/.style={font=\scriptsize\itshape, text=gray!60!black},
  regbox/.style={draw, thick, minimum height=0.7cm, font=\footnotesize},
]
  % Tree form
  \node[snode] (r) {$k_0$}
    child { node[snode] (l) {$k_1$} }
    child { node[snode] (rr) {$k_2$} };

  \node[lbl, above=3pt of r] {root};
  \node[lbl, below=3pt of l] {left};
  \node[lbl, below=3pt of rr] {right};

  % Arrow to register layout
  \draw[-{Stealth[length=5pt]}, thick, gray] (2.5, -0.5) -- (4.0, -0.5);

  % SSE register
  \node[regbox, fill=simdblk!50, minimum width=1.3cm] (r0) at (5.0, -0.5) {$k_0$};
  \node[regbox, fill=simdblk!50, minimum width=1.3cm, right=0pt of r0] (r1) {$k_1$};
  \node[regbox, fill=simdblk!50, minimum width=1.3cm, right=0pt of r1] (r2) {$k_2$};
  \node[regbox, fill=gray!10, minimum width=1.3cm, right=0pt of r2] (r3) {$\infty$};

  % Register label
  \node[lbl, above=3pt of r1.north east] {\SI{128}{bit} SSE register (\code{\_\_m128i})};
  \node[lbl, below=3pt of r0.south west, anchor=north west] {32b};
  \node[lbl, below=3pt of r1.south west, anchor=north west] {32b};
  \node[lbl, below=3pt of r2.south west, anchor=north west] {32b};
  \node[lbl, below=3pt of r3.south west, anchor=north west] {32b};

  % Sort invariant
  \node[font=\footnotesize, below=0.8cm of r1.south east]
    {Invariant: $k_1 < k_0 < k_2$ \quad (in-order $= k_1, k_0, k_2$)};

\end{tikzpicture}
\caption{\textbf{A single SIMD block (depth $\dk = 2$, 3 keys).}
  Left: the block as a complete binary tree with root $k_0$, left child
  $k_1$, and right child $k_2$.  Right: the same 3 keys packed into a
  \SI{128}{bit} SSE register in BFS order ($k_0$, $k_1$, $k_2$), with
  the fourth \SI{32}{bit} lane filled with $+\infty$ as padding.
  The in-order (sorted) traversal is $k_1 < k_0 < k_2$.}
\label{fig:simd-block}
\end{figure}

\subsection{Recursive Blocked Layout}
\label{sec:recursive-layout}

The FAST-blocked layout is constructed by recursively decomposing the
complete binary search tree into SIMD blocks.  The algorithm
(\code{lay\_out\_subtree}) works as follows:

\begin{enumerate}[nosep]
  \item Extract the top $\dk = 2$ levels of the current subtree as a
    SIMD block (3 keys in BFS order).  Write these keys contiguously
    to the output array.
  \item This SIMD block has $2^{\dk} = 4$ child subtrees (at the next
    level below).  Recursively lay out each child subtree in the same
    fashion, writing the blocks for child~0, then child~1, then child~2,
    then child~3, contiguously.
  \item Base case: when the remaining depth is $\le \dk$, write the
    final small block directly.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  snode/.style={circle, draw, minimum size=0.55cm, font=\scriptsize,
                inner sep=0pt},
  edge from parent/.style={draw, -{Stealth[length=3pt]}},
  level 1/.style={sibling distance=5.0cm, level distance=0.9cm},
  level 2/.style={sibling distance=2.5cm, level distance=0.9cm},
  level 3/.style={sibling distance=1.25cm, level distance=0.9cm},
  level 4/.style={sibling distance=0.6cm, level distance=0.9cm},
  lbl/.style={font=\tiny\itshape, text=gray!60!black},
  blk/.style={draw, thick, rounded corners=3pt, inner sep=4pt},
]
  % Tree of depth 4 (15 nodes)
  \node[snode, fill=simdblk!80] (n0) {7}
    child { node[snode, fill=simdblk!80] (n1) {3}
      child { node[snode, fill=clblk!60] (n3) {1}
        child { node[snode, fill=clblk!60] (n7) {0} }
        child { node[snode, fill=clblk!60] (n8) {2} }
      }
      child { node[snode, fill=clblk!60] (n4) {5}
        child { node[snode, fill=clblk!60] (n9) {4} }
        child { node[snode, fill=clblk!60] (n10) {6} }
      }
    }
    child { node[snode, fill=simdblk!80] (n2) {11}
      child { node[snode, fill=pageblk!60] (n5) {9}
        child { node[snode, fill=pageblk!60] (n11) {8} }
        child { node[snode, fill=pageblk!60] (n12) {10} }
      }
      child { node[snode, fill=pageblk!60] (n6) {13}
        child { node[snode, fill=pageblk!60] (n13) {12} }
        child { node[snode, fill=pageblk!60] (n14) {14} }
      }
    };

  % Block outlines
  \begin{scope}[on background layer]
    \node[blk, fill=simdblk!30, fit=(n0)(n1)(n2),
          label={[lbl, above right]north east:$B_0$ (root SIMD block)}] {};
    \node[blk, fill=clblk!20, fit=(n3)(n7)(n8),
          label={[lbl, below left]south west:$B_1$}] {};
    \node[blk, fill=clblk!20, fit=(n4)(n9)(n10),
          label={[lbl, below]south:$B_2$}] {};
    \node[blk, fill=pageblk!20, fit=(n5)(n11)(n12),
          label={[lbl, below]south:$B_3$}] {};
    \node[blk, fill=pageblk!20, fit=(n6)(n13)(n14),
          label={[lbl, below right]south east:$B_4$}] {};
  \end{scope}

  % Memory layout below
  \node[font=\footnotesize\bfseries, anchor=west] at (-6.5, -5.5) {Memory layout:};

  \foreach \i/\k/\c [count=\n from 0] in {
    0/7/simdblk!50, 1/3/simdblk!50, 2/11/simdblk!50,
    3/1/clblk!40, 4/0/clblk!40, 5/2/clblk!40,
    6/5/clblk!40, 7/4/clblk!40, 8/6/clblk!40,
    9/9/pageblk!40, 10/8/pageblk!40, 11/10/pageblk!40,
    12/13/pageblk!40, 13/12/pageblk!40, 14/14/pageblk!40
  } {
    \node[draw, minimum width=0.75cm, minimum height=0.6cm, fill=\c,
          font=\scriptsize, anchor=west]
      (m\n) at ({-5.5 + \n * 0.8}, -6.3) {\k};
    \node[font=\tiny, text=gray] at ({-5.5 + \n * 0.8 + 0.375}, -6.85) {\n};
  }

  % Block brackets
  \draw[decorate, decoration={brace, amplitude=3pt}]
    ([yshift=2pt]m0.north west) -- ([yshift=2pt]m2.north east)
    node[midway, above=4pt, font=\tiny] {$B_0$};
  \draw[decorate, decoration={brace, amplitude=3pt}]
    ([yshift=2pt]m3.north west) -- ([yshift=2pt]m5.north east)
    node[midway, above=4pt, font=\tiny] {$B_1$};
  \draw[decorate, decoration={brace, amplitude=3pt}]
    ([yshift=2pt]m6.north west) -- ([yshift=2pt]m8.north east)
    node[midway, above=4pt, font=\tiny] {$B_2$};
  \draw[decorate, decoration={brace, amplitude=3pt}]
    ([yshift=2pt]m9.north west) -- ([yshift=2pt]m11.north east)
    node[midway, above=4pt, font=\tiny] {$B_3$};
  \draw[decorate, decoration={brace, amplitude=3pt}]
    ([yshift=2pt]m12.north west) -- ([yshift=2pt]m14.north east)
    node[midway, above=4pt, font=\tiny] {$B_4$};

\end{tikzpicture}
\caption{\textbf{Recursive SIMD-block decomposition of a depth-4 tree (15 keys).}
  Top: the complete binary search tree with keys $0$--$14$ (in-order values).
  The root SIMD block $B_0$ (gold, depth 2) contains BFS nodes \{7, 3, 11\}.
  Its four child subtrees form blocks $B_1$ (violet, \{1, 0, 2\}),
  $B_2$ (violet, \{5, 4, 6\}), $B_3$ (rose, \{9, 8, 10\}), and
  $B_4$ (rose, \{13, 12, 14\}).
  Bottom: the \code{layout[]} array stores blocks contiguously in
  pre-order: $B_0$, $B_1$, $B_2$, $B_3$, $B_4$.
  Array indices are shown below each cell.}
\label{fig:blocked-layout}
\end{figure}


\subsection{The \code{sorted\_rank} Mapping}
\label{sec:sorted-rank}

Because the blocked layout reorders keys from their sorted sequence,
we need a way to recover the sorted position of any key encountered
during search.  The \code{sorted\_rank[]} array provides this:

\[
  \code{sorted\_rank}[i] = j
  \quad\Longleftrightarrow\quad
  \code{layout}[i] \text{ is the $j$-th smallest key in the leaf}
\]

This mapping is computed during leaf construction (\code{mt\_leaf\_build})
by performing an in-order traversal of the implicit BFS tree and
recording the visit count.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  cell/.style={draw, minimum width=0.85cm, minimum height=0.6cm,
               font=\scriptsize, anchor=west},
  lbl/.style={font=\scriptsize\bfseries},
  idx/.style={font=\tiny, text=gray},
]
  % Index row
  \node[lbl, anchor=east] at (-0.3, 0.8) {index $i$:};
  \foreach \i in {0,...,6} {
    \node[idx] at ({0.425 + \i * 0.85}, 0.8) {\i};
  }

  % layout row
  \node[lbl, anchor=east] at (-0.3, 0) {\code{layout[]}:};
  \foreach \i/\v/\c in {0/7/simdblk!50, 1/3/simdblk!50, 2/11/simdblk!50,
                          3/1/clblk!40, 4/0/clblk!40, 5/2/clblk!40,
                          6/5/clblk!40} {
    \node[cell, fill=\c] at ({\i * 0.85}, 0) {\v};
  }
  \node[cell, fill=white, draw=gray!50, text=gray] at ({7*0.85}, 0) {$\cdots$};

  % sorted_rank row
  \node[lbl, anchor=east] at (-0.3, -0.9) {\code{sorted\_rank[]}:};
  \foreach \i/\v in {0/3, 1/1, 2/5, 3/0, 4/\textbf{0}, 5/2, 6/4} {
    \node[cell, fill=rankcolor!60] at ({\i * 0.85}, -0.9) {\v};
  }
  \node[cell, fill=white, draw=gray!50, text=gray] at ({7*0.85}, -0.9) {$\cdots$};

  % Explanation
  \node[font=\scriptsize, anchor=west, text width=8cm] at (0, -2.0) {%
    Example: \code{layout[0]} = 7 and \code{sorted\_rank[0]} = 3, meaning
    key~7 is the 4th-smallest key (0-indexed rank~3) in sorted order.
    \code{layout[4]} = 0 with \code{sorted\_rank[4]} = 0, meaning key~0
    is the smallest.};
\end{tikzpicture}
\caption{\textbf{The \code{sorted\_rank} mapping} for the first 7 positions
  of the blocked layout from Figure~\ref{fig:blocked-layout}.
  Each entry \code{sorted\_rank[$i$]} gives the position that
  \code{layout[$i$]} occupies in sorted order.}
\label{fig:sorted-rank}
\end{figure}


% ══════════════════════════════════════════════════════════════════
\section{SIMD Search Operations}
\label{sec:simd-search}

\subsection{SIMD Comparison and Child Selection}
\label{sec:simd-cmp}

Within a SIMD block of 3 keys ($k_0, k_1, k_2$ in BFS order), a
predecessor query for key $q$ proceeds as follows:

\begin{enumerate}[nosep]
  \item Load the 3 block keys plus a padding $\infty$ into a \SI{128}{bit}
    SSE register: $\mathbf{v}_{\text{tree}} = (k_0, k_1, k_2, \infty)$.
  \item Broadcast the query key: $\mathbf{v}_q = (q, q, q, q)$.
  \item Compute the element-wise comparison
    $\mathbf{v}_{\text{cmp}} = \code{\_mm\_cmpgt\_epi32}(\mathbf{v}_q,
    \mathbf{v}_{\text{tree}})$, yielding a \SI{128}{bit} mask where
    lane~$j$ is all-ones iff $q > k_j$.
  \item Extract the sign bits as a 4-bit integer:
    $\mathit{mask} = \code{\_mm\_movemask\_ps}(\mathbf{v}_{\text{cmp}})$.
  \item Index into the lookup table \code{MT\_SIMD\_LOOKUP[mask \& 0x7]}
    to get the child index $c \in \{0, 1, 2, 3\}$.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  reg/.style={draw, minimum width=1.8cm, minimum height=0.7cm,
              font=\footnotesize, anchor=west},
  lbl/.style={font=\scriptsize\bfseries, anchor=east},
  arrow/.style={-{Stealth[length=5pt]}, thick},
  note/.style={font=\scriptsize\itshape, text=gray!60!black},
]
  % v_tree
  \node[lbl] at (-0.3, 2.0) {$\mathbf{v}_{\text{tree}}$:};
  \node[reg, fill=simdblk!50] (t0) at (0, 2.0) {$k_0 = 50$};
  \node[reg, fill=simdblk!50, right=0pt of t0] (t1) {$k_1 = 20$};
  \node[reg, fill=simdblk!50, right=0pt of t1] (t2) {$k_2 = 80$};
  \node[reg, fill=gray!15, right=0pt of t2] (t3) {$\infty$};

  % v_q
  \node[lbl] at (-0.3, 1.0) {$\mathbf{v}_q$:};
  \node[reg, fill=blue!10] (q0) at (0, 1.0) {$q = 35$};
  \node[reg, fill=blue!10, right=0pt of q0] (q1) {$q = 35$};
  \node[reg, fill=blue!10, right=0pt of q1] (q2) {$q = 35$};
  \node[reg, fill=blue!10, right=0pt of q2] (q3) {$q = 35$};

  % Operation label
  \node[note, right=0.5cm of t3] {\code{\_mm\_loadu\_si128}};
  \node[note, right=0.5cm of q3] {\code{\_mm\_set1\_epi32}};

  % cmpgt
  \draw[arrow] (3.6, 0.6) -- (3.6, 0.0) node[midway, right, note]
    {\code{\_mm\_cmpgt\_epi32}$(v_q, v_{\text{tree}})$};

  % v_cmp
  \node[lbl] at (-0.3, -0.5) {$\mathbf{v}_{\text{cmp}}$:};
  \node[reg, fill=red!15] (c0) at (0, -0.5) {0\quad{\tiny($35\ngtr 50$)}};
  \node[reg, fill=green!15, right=0pt of c0] (c1) {1\quad{\tiny($35>20$)}};
  \node[reg, fill=red!15, right=0pt of c1] (c2) {0\quad{\tiny($35\ngtr 80$)}};
  \node[reg, fill=red!15, right=0pt of c2] (c3) {0\quad{\tiny($35\ngtr\infty$)}};

  % movemask
  \draw[arrow] (3.6, -1.0) -- (3.6, -1.6) node[midway, right, note]
    {\code{\_mm\_movemask\_ps}};

  % mask value
  \node[lbl] at (-0.3, -2.0) {mask:};
  \node[font=\footnotesize, anchor=west] at (0, -2.0)
    {\code{0b0010} $= 2$ \quad $\Rightarrow$ \quad
     \code{MT\_SIMD\_LOOKUP[2]} $= 1$ \quad $\Rightarrow$ \quad
     child index $c = 1$};

  % Interpretation
  \node[font=\scriptsize, anchor=west, text width=9cm] at (0, -2.8) {%
    Interpretation: $q = 35$ is greater than $k_1 = 20$ (left child) but
    not greater than $k_0 = 50$ (root).  In the binary search tree, this
    means $q$ falls between $k_1$ and $k_0$, which is child subtree~1
    (the right child of the left child).};

\end{tikzpicture}
\caption{\textbf{SIMD comparison within one SIMD block.}
  Query $q = 35$ is compared against block keys $(50, 20, 80)$.
  The \code{cmpgt} result shows $q > 20$ only (lane~1).
  The movemask extracts \code{0b0010}$=2$, and the lookup table
  maps this to child index $c = 1$.  This selects the second of four
  child subtrees.}
\label{fig:simd-cmp}
\end{figure}

\paragraph{Lookup table derivation.}
The 3 keys in BFS order form a complete binary tree: root $k_0$, left
child $k_1 < k_0$, right child $k_2 > k_0$.  The 3-bit comparison mask
encodes which keys the query exceeds:

\begin{center}
\small
\begin{tabular}{@{}ccl@{}}
\toprule
\textbf{Mask (bits 2:1:0)} & \textbf{Child} & \textbf{Meaning} \\
\midrule
\code{000} & 0 & $q \le k_1 < k_0 < k_2$: leftmost subtree \\
\code{010} & 1 & $k_1 < q \le k_0 < k_2$: second subtree \\
\code{011} & 2 & $k_1 < k_0 < q \le k_2$: third subtree \\
\code{111} & 3 & $k_1 < k_0 < k_2 < q$: rightmost subtree \\
\bottomrule
\end{tabular}
\end{center}

Other mask values (e.g., \code{001}, \code{100}) are impossible for valid
search trees because $k_1 < k_0 < k_2$ always holds.


\subsection{Full Leaf Search Path}
\label{sec:leaf-search-path}

A search within a leaf traverses a sequence of SIMD blocks from the root
block $B_0$ down to a leaf block.  At each block, the SIMD comparison
yields a child index~$c$, and the next block's offset is computed as:
\begin{equation}
  \mathit{offset}_{\text{next}} = \mathit{offset}_{\text{current}} + \nk +
    c \cdot (\text{child subtree size})
\label{eq:offset-next}
\end{equation}
where the child subtree size is $2^{d_{\text{remaining}}} - 1$ keys.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  blk/.style={draw, thick, rounded corners=3pt, minimum width=2.0cm,
              minimum height=0.8cm, font=\footnotesize, fill=simdblk!50},
  arrow/.style={-{Stealth[length=5pt]}, thick, ptrcolor},
  lbl/.style={font=\tiny\itshape, text=gray!60!black},
  highlight/.style={very thick, red!70!black},
]
  % Root block
  \node[blk] (b0) at (0, 0) {$B_0$: $k_0, k_1, k_2$};
  \node[lbl, above=2pt of b0] {offset = 0};

  % Level 1 blocks
  \node[blk] (b1) at (-4.5, -1.8) {$B_1$: $k_3, k_4, k_5$};
  \node[blk, fill=simdblk!80, highlight] (b2) at (-1.5, -1.8) {$B_2$: $k_6, k_7, k_8$};
  \node[blk] (b3) at (1.5, -1.8) {$B_3$: $k_9, k_{10}, k_{11}$};
  \node[blk] (b4) at (4.5, -1.8) {$B_4$: $k_{12}, k_{13}, k_{14}$};

  \node[lbl, above=2pt of b1] {off = 3};
  \node[lbl, above=2pt of b2] {off = 6};
  \node[lbl, above=2pt of b3] {off = 9};
  \node[lbl, above=2pt of b4] {off = 12};

  % Child labels
  \node[lbl, below=1pt of b0.south west, xshift=-4pt] {$c{=}0$};
  \node[lbl, below=1pt of b0.south, xshift=-8pt] {$c{=}1$};
  \node[lbl, below=1pt of b0.south, xshift=8pt] {$c{=}2$};
  \node[lbl, below=1pt of b0.south east, xshift=4pt] {$c{=}3$};

  % Arrows from root
  \draw[arrow, gray!50] (b0.south west) ++(0.2cm,0) -- (b1.north);
  \draw[arrow, highlight] (b0.south) ++(-0.2cm,0) -- (b2.north)
    node[midway, right, font=\scriptsize, red!70!black] {$c = 1$};
  \draw[arrow, gray!50] (b0.south) ++(0.2cm,0) -- (b3.north);
  \draw[arrow, gray!50] (b0.south east) ++(-0.2cm,0) -- (b4.north);

  % Deeper level (children of B2)
  \node[blk, fill=simdblk!30, minimum width=1.2cm] (b5) at (-3.0, -3.6) {\tiny$B_5$};
  \node[blk, fill=simdblk!30, minimum width=1.2cm] (b6) at (-1.5, -3.6) {\tiny$B_6$};
  \node[blk, fill=simdblk!80, minimum width=1.2cm, highlight] (b7) at (0.0, -3.6) {\tiny$B_7$};
  \node[blk, fill=simdblk!30, minimum width=1.2cm] (b8) at (1.5, -3.6) {\tiny$B_8$};

  \draw[arrow, gray!50] (b2.south west) ++(0.1cm,0) -- (b5.north);
  \draw[arrow, gray!50] (b2.south) ++(-0.15cm,0) -- (b6.north);
  \draw[arrow, highlight] (b2.south) ++(0.15cm,0) -- (b7.north)
    node[midway, right, font=\scriptsize, red!70!black] {$c = 2$};
  \draw[arrow, gray!50] (b2.south east) ++(-0.1cm,0) -- (b8.north);

  % Search path label
  \node[font=\small\itshape, red!70!black, anchor=west] at (-5.5, -4.5)
    {Search path: $B_0 \xrightarrow{c=1} B_2 \xrightarrow{c=2} B_7$};

\end{tikzpicture}
\caption{\textbf{Search path through SIMD blocks within a leaf.}
  Starting at root block $B_0$ (offset~0), the SIMD comparison yields
  child index $c = 1$, directing the search to block $B_2$ (offset~6).
  A second comparison at $B_2$ yields $c = 2$, directing to block $B_7$.
  The red highlighted path shows the blocks visited.  At each step,
  the next offset is computed as $\mathit{offset} + 3 + c \times
  (\text{child subtree size})$.  Gray arrows show unvisited branches.}
\label{fig:search-path}
\end{figure}


\subsection{Predecessor Resolution}
\label{sec:predecessor}

After the SIMD traversal reaches the bottom of the blocked tree, we must
resolve the actual predecessor key.  The search terminates at a SIMD block
with a child index $c$ that identifies the ``gap'' in sorted order where
the query falls.  Using the \code{sorted\_rank[]} mapping, we determine
the rank of the boundary key adjacent to this gap, then extract the
predecessor from the sorted key sequence.

Specifically, after the final SIMD block at offset $o$ with child index
$c$:

\begin{center}
\small
\begin{tabular}{@{}cl@{}}
\toprule
\textbf{Child $c$} & \textbf{Predecessor rank} \\
\midrule
0 & $\code{sorted\_rank}[o + 1] - 1$ \quad (left of leftmost key) \\
1 & $\code{sorted\_rank}[o + 1]$ \quad (between left child and root) \\
2 & $\code{sorted\_rank}[o]$ \quad (between root and right child) \\
3 & $\code{sorted\_rank}[o + 2]$ \quad (right of rightmost key) \\
\bottomrule
\end{tabular}
\end{center}

This rank is then used to index into the sorted key array (reconstructed
on-stack via \code{mt\_leaf\_extract\_sorted}) for the final predecessor
value.

% ══════════════════════════════════════════════════════════════════
\section{Tree Operations}
\label{sec:operations}

\subsection{Bulk Load}
\label{sec:bulk-load}

Bulk loading constructs the tree bottom-up from a pre-sorted array of
$n$ keys in $\Oh(n)$ time.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  leaf/.style={draw, fill=leafcolor, rounded corners=2pt,
               minimum width=1.8cm, minimum height=0.9cm,
               font=\scriptsize, align=center},
  inode/.style={draw, fill=inodecolor, rounded corners=2pt,
                minimum width=2.5cm, minimum height=0.7cm,
                font=\scriptsize, align=center},
  arr/.style={draw, minimum width=0.5cm, minimum height=0.5cm,
              font=\tiny, anchor=west},
  arrow/.style={-{Stealth[length=4pt]}, thick, ptrcolor},
  lbl/.style={font=\scriptsize\itshape, text=gray!60!black},
  phase/.style={font=\small\bfseries, anchor=west},
]

  % Phase 1: sorted array
  \node[phase] at (-6, 3.5) {Phase 1: Partition sorted keys into leaves};
  \foreach \i/\k in {0/0, 1/1, 2/2, 3/3, 4/4, 5/5, 6/6, 7/7, 8/8, 9/9} {
    \node[arr, fill=orange!20] (a\i) at ({-5.0 + \i * 0.55}, 2.8) {\k};
  }
  \node[font=\tiny] at ({-5.0 + 10*0.55 + 0.3}, 2.8) {$\cdots$};
  \node[lbl, above=2pt of a0.north west, anchor=south west] {sorted keys[]};

  % Arrows to leaves
  \draw[decorate, decoration={brace, amplitude=4pt, mirror}]
    (a0.south west) ++(0,-0.1) -- (a3.south east) ++(0,-0.1)
    node[midway, below=5pt, font=\tiny] {};
  \draw[decorate, decoration={brace, amplitude=4pt, mirror}]
    (a4.south west) ++(0,-0.1) -- (a7.south east) ++(0,-0.1);
  \draw[decorate, decoration={brace, amplitude=4pt, mirror}]
    (a8.south west) ++(0,-0.1) -- (a9.south east) ++(0,-0.1);

  % Phase 2: leaf nodes
  \node[phase] at (-6, 1.2) {Phase 2: Build FAST layout per leaf};
  \node[leaf] (l0) at (-3.5, 0.5) {$L_0$\\keys 0--3};
  \node[leaf] (l1) at (-0.5, 0.5) {$L_1$\\keys 4--7};
  \node[leaf] (l2) at (2.5, 0.5) {$L_2$\\keys 8--$\cdots$};

  \draw[arrow] (-3.5, 1.9) -- (l0.north);
  \draw[arrow] (-0.5, 1.9) -- (l1.north);
  \draw[arrow] (2.5, 1.9) -- (l2.north);

  % Leaf links
  \draw[-{Stealth[length=3pt]}, red!60!black, dashed, thick]
    (l0.east) -- (l1.west) node[midway, above, lbl] {next};
  \draw[-{Stealth[length=3pt]}, red!60!black, dashed, thick]
    (l1.east) -- (l2.west) node[midway, above, lbl] {next};

  % Phase 3: internal nodes
  \node[phase] at (-6, -0.8) {Phase 3: Build internal levels bottom-up};
  \node[inode] (i0) at (-0.5, -1.5) {$I_0$: sep = \{$k(L_1), k(L_2)$\}};

  \draw[arrow] (i0.south west) ++(0.3, 0) -- (l0.south)
    node[midway, left, lbl] {$p_0$};
  \draw[arrow] (i0.south) -- (l1.south east)
    node[midway, left, lbl] {$p_1$};
  \draw[arrow] (i0.south east) ++(-0.3, 0) -- (l2.south)
    node[midway, right, lbl] {$p_2$};

  \node[lbl, right=0.3cm of i0] {(root if only one parent needed)};

\end{tikzpicture}
\caption{\textbf{Bulk load construction.}
  \textbf{Phase~1}: The sorted key array is partitioned into groups of
  up to 511 keys each.
  \textbf{Phase~2}: Each group is passed to \code{mt\_leaf\_build}, which
  constructs the FAST-blocked layout and \code{sorted\_rank} array.
  Leaves are linked via \code{prev}/\code{next} pointers.
  \textbf{Phase~3}: Internal nodes are built bottom-up.  Each parent receives
  separator keys (the minimum key of each non-first child) and child pointers.
  If more than one parent is needed, the process recurses upward until a single
  root remains.}
\label{fig:bulk-load}
\end{figure}

The algorithm distributes keys evenly across $\ceil{n / 511}$ leaves,
builds each leaf's FAST layout via \code{mt\_leaf\_build}, links leaves
into a doubly-linked list, then iteratively constructs internal levels.
At each internal level, child nodes are grouped into parents of up to
340 children (339 separator keys), and the process repeats until a single
root remains.

Separator keys are the minimum key of each non-leftmost child, which is
tracked during construction via the \code{build\_entry\_t} structure
(avoiding the cost of walking into each child to find its minimum).

\subsection{Point Query and Predecessor Search}
\label{sec:search}

A predecessor search for query~$q$ finds the largest key $k \le q$ in
the tree:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  step/.style={draw, rounded corners=3pt, minimum width=3.5cm,
               minimum height=0.8cm, font=\small, align=center},
  arrow/.style={-{Stealth[length=5pt]}, thick},
  lbl/.style={font=\scriptsize\itshape, text=gray!60!black},
]
  \node[step, fill=inodecolor] (s1) at (0, 0) {Walk internal levels};
  \node[step, fill=leafcolor] (s2) at (0, -1.5) {SIMD leaf search};
  \node[step, fill=rankcolor] (s3) at (0, -3.0) {Resolve predecessor};

  \draw[arrow] (s1) -- (s2) node[midway, right, lbl] {$\Oh(\log_B n)$ pointer follows};
  \draw[arrow] (s2) -- (s3) node[midway, right, lbl] {$\ceil{\dn/\dk}$ SIMD comparisons};

  \node[lbl, right=0.3cm of s1, text width=5cm]
    {At each internal node, \code{mt\_inode\_search} returns child index $i$;
     follow \code{children[$i$]}};
  \node[lbl, right=0.3cm of s2, text width=5cm]
    {Traverse SIMD blocks within the leaf (Figure~\ref{fig:search-path})};
  \node[lbl, right=0.3cm of s3, text width=5cm]
    {Use \code{sorted\_rank[]} to find predecessor rank;
     extract sorted keys; return \code{sorted[rank]}};
\end{tikzpicture}
\caption{\textbf{Predecessor search procedure.}
  Three phases: (1)~top-down traversal through internal levels using
  SIMD-accelerated search at each node; (2)~SIMD block traversal within
  the target leaf; (3)~predecessor resolution using the rank mapping.}
\label{fig:search-procedure}
\end{figure}

\subsection{Insert}
\label{sec:insert}

Insertion follows the standard B\textsuperscript{+} tree procedure,
with the key difference that each leaf modification requires a full
rebuild of the FAST layout:

\begin{enumerate}[nosep]
  \item \textbf{Find leaf}: Walk the tree from root to the target leaf,
    recording the path of internal nodes and child indices in a
    \code{mt\_path\_t} stack.
  \item \textbf{Extract sorted keys}: Call \code{mt\_leaf\_extract\_sorted}
    to recover the logical sorted order from the FAST layout.
  \item \textbf{Insert into sorted array}: Binary-search for the insertion
    point and shift elements (rejecting duplicates).
  \item \textbf{If no overflow} ($n \le 511$): Rebuild the leaf's FAST
    layout via \code{mt\_leaf\_build}. Done.
  \item \textbf{If overflow} ($n = 512$): \textbf{Split} the leaf.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  leaf/.style={draw, fill=leafcolor, rounded corners=2pt,
               minimum width=4.5cm, minimum height=1.0cm,
               font=\scriptsize, align=center},
  inode/.style={draw, fill=inodecolor, rounded corners=2pt,
                minimum width=4.5cm, minimum height=0.7cm,
                font=\scriptsize, align=center},
  arr/.style={draw, minimum width=0.35cm, minimum height=0.4cm,
              font=\tiny, anchor=west, fill=orange!15},
  arrow/.style={-{Stealth[length=4pt]}, thick},
  lbl/.style={font=\scriptsize\itshape, text=gray!60!black},
  splitarrow/.style={-{Stealth[length=5pt]}, very thick, red!70!black},
]
  % Before split
  \node[font=\small\bfseries] at (-3.5, 3.2) {Before (leaf overflow):};

  \node[leaf, minimum width=7cm] (full) at (0, 2.5)
    {$L$: 512 sorted keys after insertion\quad (exceeds max 511)};

  % Arrow: split
  \draw[splitarrow] (0, 1.8) -- (0, 1.2)
    node[midway, right, font=\scriptsize, red!70!black] {split at midpoint};

  % After split
  \node[font=\small\bfseries] at (-3.5, 0.7) {After:};

  \node[leaf, minimum width=3.5cm] (left) at (-2.0, 0.0)
    {$L_{\text{left}}$: keys $0 \ldots 255$};
  \node[leaf, minimum width=3.5cm] (right) at (2.5, 0.0)
    {$L_{\text{right}}$: keys $256 \ldots 511$};

  % Leaf links
  \draw[-{Stealth[length=3pt]}, red!60!black, dashed]
    (left.east) -- (right.west) node[midway, above, lbl] {next};
  \draw[-{Stealth[length=3pt]}, red!60!black, dashed]
    (right.west) ++(0,-0.15) -- (left.east |- right.west) ++(0,-0.15)
    node[midway, below, lbl] {prev};

  % Separator pushed up
  \draw[arrow, ptrcolor] (0.25, -0.5) -- (0.25, -1.3)
    node[midway, right, lbl] {push separator $k_{256}$ to parent};

  \node[inode] (parent) at (0.25, -1.8)
    {Parent: $\ldots\; k_{256} \;\ldots$};

  \draw[arrow, ptrcolor] (parent.north west) ++(0.5,0) -- (left.south east)
    node[midway, left, lbl] {$p_i$};
  \draw[arrow, ptrcolor] (parent.north east) ++(-0.5,0) -- (right.south west)
    node[midway, right, lbl] {$p_{i+1}$};

  % Note about rebuild
  \node[font=\scriptsize, text width=6cm, anchor=north west] at (-4.5, -2.6) {%
    Both $L_{\text{left}}$ and $L_{\text{right}}$ have their FAST layouts
    rebuilt from scratch via \code{mt\_leaf\_build}.  The parent internal
    node receives the separator key $k_{256}$ (the first key of the right
    leaf) and a new child pointer.  If the parent overflows, it splits
    recursively.};
\end{tikzpicture}
\caption{\textbf{Leaf split during insertion.}
  When a leaf exceeds 511 keys, it is split at the midpoint into two
  leaves.  Both leaves' FAST layouts are rebuilt.  The separator key
  (minimum key of the right leaf) is pushed to the parent internal node.
  The leaf linked list is updated to splice in the new right leaf.}
\label{fig:leaf-split}
\end{figure}

If the parent internal node also overflows (exceeds 339 keys), it splits
analogously: the keys and children are divided at the midpoint, with the
middle key promoted to the grandparent.  If splits propagate all the way
to the root, a new root is created with one key and two children, increasing
the tree height by~1.

\paragraph{Modification cost.}
Each insert extracts the leaf's sorted keys ($\Oh(B)$), inserts into
the sorted array ($\Oh(B)$), and rebuilds the FAST layout ($\Oh(B)$),
where $B = 511$.  Splits propagate through at most $\Oh(\log_B n)$
internal levels, each requiring $\Oh(B)$ work.  Thus the total insert
cost is $\Oh(B \cdot \log_B n)$.

\subsection{Delete}
\label{sec:delete}

Deletion uses the same find-leaf, extract-sorted, modify, rebuild pattern
as insertion.  The current implementation uses \textbf{lazy deletion}: it
does not merge or redistribute underfull leaves.  A leaf that becomes
completely empty is unlinked from the leaf chain and removed from its
parent; if the parent becomes empty and is the root, the tree height
decreases.

\subsection{Range Scan (Iteration)}
\label{sec:iteration}

Range scans exploit the doubly-linked leaf list.  An iterator is
initialised by walking from the root to the leaf containing the start
key, extracting that leaf's sorted keys into an internal buffer, and
positioning at the first key $\ge$ start.  Subsequent \code{iter\_next}
calls advance through the buffer; when the buffer is exhausted, the
iterator follows the \code{next} pointer to the adjacent leaf, extracts
its sorted keys, and continues.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
  leaf/.style={draw, fill=leafcolor, rounded corners=2pt,
               minimum width=2.2cm, minimum height=0.9cm,
               font=\scriptsize, align=center},
  arrow/.style={-{Stealth[length=4pt]}, thick, red!60!black, dashed},
  lbl/.style={font=\scriptsize\itshape, text=gray!60!black},
  cursor/.style={draw, thick, red!70!black, -{Stealth[length=5pt]}},
]
  \node[leaf] (l0) at (0, 0)    {$L_0$\\256 keys};
  \node[leaf] (l1) at (3.0, 0)  {$L_1$\\256 keys};
  \node[leaf] (l2) at (6.0, 0)  {$L_2$\\256 keys};
  \node[leaf] (l3) at (9.0, 0)  {$L_3$\\180 keys};

  \draw[arrow] (l0.east) -- (l1.west) node[midway, above, lbl] {next};
  \draw[arrow] (l1.east) -- (l2.west) node[midway, above, lbl] {next};
  \draw[arrow] (l2.east) -- (l3.west) node[midway, above, lbl] {next};

  % Iterator position
  \node[font=\scriptsize, red!70!black] (iter) at (3.0, 1.5) {iterator};
  \draw[cursor] (iter.south) -- (l1.north);

  % Buffer
  \node[draw, fill=orange!10, minimum width=2.2cm, minimum height=0.5cm,
        font=\scriptsize] (buf) at (3.0, -1.2) {sorted[0..255]};
  \draw[-{Stealth[length=3pt]}, thick, gray] (l1.south) -- (buf.north)
    node[midway, right, lbl] {extract};

  \node[lbl, below=3pt of buf] {Iterator's internal sorted key buffer};
  \node[lbl, right=0.3cm of l3] {\code{next = NULL}};

\end{tikzpicture}
\caption{\textbf{Iterator traversal via leaf linked list.}
  The iterator is positioned at leaf $L_1$.  It has extracted $L_1$'s
  sorted keys into an internal buffer and yields them one by one.
  When the buffer is exhausted, the iterator follows $L_1$.\code{next}
  to $L_2$, extracts its keys, and continues.  The red dashed arrows
  show the \code{next} pointers forming the linked list.}
\label{fig:iterator}
\end{figure}


% ══════════════════════════════════════════════════════════════════
\section{Complexity Analysis}
\label{sec:complexity}

Table~\ref{tab:complexity} summarises the asymptotic costs of matryoshka
tree operations, where $n$ is the total number of keys and $B$ is the
leaf node capacity (511).

\begin{table}[H]
\centering
\caption{\textbf{Operation costs.}
  $B = 511$ (leaf capacity), $F = 340$ (internal fanout),
  $h = \ceil{\log_F(n/B)}$ (tree height).}
\label{tab:complexity}
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Operation} & \textbf{Asymptotic Cost} & \textbf{Notes} \\
\midrule
Bulk load       & $\Oh(n)$ & Bottom-up, one pass \\
Point search    & $\Oh(h + \dn/\dk)$ & $h$ pointer follows + SIMD leaf search \\
Predecessor     & $\Oh(h + \dn/\dk)$ & Same as point search + rank lookup \\
Insert          & $\Oh(B \cdot h)$ worst case & Leaf rebuild + possible splits \\
Delete          & $\Oh(B)$ amortised & Leaf rebuild; lazy (no merge) \\
Range scan      & $\Oh(h + m)$ & $h$ for initial seek, $m$ keys scanned \\
Iteration (next)& $\Oh(1)$ amortised & $\Oh(B)$ per leaf transition \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Concrete numbers.}
For $n = 10{,}000{,}000$ keys:
\begin{itemize}[nosep]
  \item Leaves: $\ceil{10^7 / 511} = 19{,}570$ leaves.
  \item Internal fanout: $F = 340$.
  \item Height: $h = \ceil{\log_{340}(19{,}570)} \approx 2$.
  \item Leaf tree depth: $\dn = 9$ levels, requiring $\ceil{9/2} = 5$
    SIMD comparisons.
  \item Total comparisons per search: 2 internal node lookups + 5 SIMD
    block comparisons = 7 comparison steps.
\end{itemize}


% ══════════════════════════════════════════════════════════════════
\section{Cache Behaviour Analysis}
\label{sec:cache}

The matryoshka tree's performance depends critically on how its data
structures interact with the CPU cache hierarchy.  We analyse cache
behaviour at each level.

\subsection{Within a Leaf (SIMD Blocks)}

Each SIMD block occupies 3 keys $\times$ \SI{4}{\byte} = \SI{12}{\byte},
fitting entirely within a single \SI{16}{\byte} SSE register.  The SIMD
\code{loadu} instruction loads the block in one cycle (if the data is in
L1).  Because the blocked layout stores parent and child SIMD blocks
contiguously, a root-to-leaf traversal within a leaf typically touches
at most 2--3 cache lines (for the \code{layout[]} array) plus 1--2 cache
lines (for the \code{sorted\_rank[]} array) during predecessor resolution.

\subsection{Between Nodes (B\textsuperscript{+} Pointers)}

Each internal-to-child pointer follow incurs a potential TLB miss if the
child resides on a different virtual page.  Since nodes are page-aligned,
each node occupies exactly one TLB entry.  The TLB cost per search is
bounded by the tree height $h$, which is typically 1--2 for trees up to
$10^8$ keys.

\subsection{Comparison with FAST}

FAST trees eliminate all pointer follows by storing the entire index in a
contiguous array.  For trees that fit in L2/L3 cache, FAST achieves
higher throughput because no TLB miss ever occurs.  The matryoshka tree
trades a small number of pointer follows (1--2 per search) for the
ability to modify the tree without rebuilding.  For workloads with even
moderate insertion rates, the $\Oh(n)$ rebuild cost of FAST quickly
dominates, making the matryoshka tree's $\Oh(B \cdot \log_B n)$ insert
cost advantageous.


% ══════════════════════════════════════════════════════════════════
\section{Implementation Notes}
\label{sec:impl}

\subsection{Memory Allocation}

All nodes are allocated via \code{posix\_memalign} with \SI{4096}{\byte}
alignment and size, ensuring one-page-per-node correspondence:

\begin{lstlisting}
posix_memalign(&p, MT_PAGE_SIZE, MT_PAGE_SIZE);  /* 4096, 4096 */
memset(p, 0, MT_PAGE_SIZE);
\end{lstlisting}

The \code{mt\_node\_t} union allows type-punning between internal and leaf
nodes via a shared \code{type} field at offset~0.

\subsection{Leaf Build Algorithm}

The \code{mt\_leaf\_build} function constructs the FAST-blocked layout from
a sorted key array in three steps:

\begin{enumerate}[nosep]
  \item \textbf{Compute tree depth}: $\dn = \ceil{\log_2(n+1)}$, giving
    $2^{\dn} - 1$ tree nodes (some may be $+\infty$ padding).
  \item \textbf{Build in-order map}: An iterative in-order traversal of
    the implicit BFS tree computes \code{bfs\_to\_sorted[i]} = the sorted
    rank of BFS node~$i$.
  \item \textbf{Construct BFS tree}: For each BFS node~$i$, set
    \code{bfs\_tree[$i$] = sorted\_keys[bfs\_to\_sorted[$i$]]}, or
    $+\infty$ if the rank exceeds $n$.
  \item \textbf{Recursive layout}: \code{lay\_out\_subtree} decomposes the
    BFS tree into SIMD blocks, writing each block's keys and ranks
    contiguously to the output arrays.
\end{enumerate}

\subsection{Limitations and Future Work}

\begin{itemize}[nosep]
  \item \textbf{Per-search key reconstruction}: The current search
    implementation extracts sorted keys on each query ($\Oh(B)$ per
    search) for predecessor resolution.  This can be eliminated by
    directly computing the predecessor during the SIMD traversal,
    avoiding the reconstruction entirely.

  \item \textbf{Cache-line blocking}: The implementation currently uses
    only SIMD-level blocking ($\dk = 2$).  Adding cache-line blocking
    ($\dl = 4$) would group five SIMD blocks into a \SI{64}{\byte}
    cache-line--sized unit, potentially improving cache utilisation for
    large leaves.

  \item \textbf{Concurrency}: No locking or versioning is implemented.
    Optimistic lock coupling~\cite{lehman1981efficient} or epoch-based
    reclamation would be needed for concurrent access.

  \item \textbf{Lazy deletion}: The current delete does not merge or
    redistribute underfull leaves, which may waste space under heavy
    deletion workloads.

  \item \textbf{Variable-length keys}: The current design is specialised
    for 32-bit integers.  Supporting variable-length keys would require
    indirection or key normalisation, similar to Masstree's approach.
\end{itemize}


% ══════════════════════════════════════════════════════════════════
\section{Compilation Constants}
\label{sec:constants}

\begin{table}[H]
\centering
\caption{\textbf{Compile-time constants} defined in \code{matryoshka\_internal.h}.}
\label{tab:constants}
\small
\begin{tabular}{@{}lrl@{}}
\toprule
\textbf{Constant} & \textbf{Value} & \textbf{Description} \\
\midrule
\code{MT\_PAGE\_SIZE}      & 4096  & Page size in bytes; node allocation unit \\
\code{MT\_DK}              & 2     & SIMD block depth \\
\code{MT\_NK}              & 3     & Keys per SIMD block ($2^{\dk}-1$) \\
\code{MT\_DL}              & 4     & Cache-line block depth (reserved) \\
\code{MT\_NL}              & 15    & Keys per cache-line block ($2^{\dl}-1$) \\
\code{MT\_MAX\_IKEYS}      & 339   & Max keys per internal node \\
\code{MT\_MIN\_IKEYS}      & 169   & Min keys per internal node ($\floor{339/2}$) \\
\code{MT\_LNODE\_TREE\_CAP}& 512   & Array capacity in leaf ($\ge 2^9 - 1$) \\
\code{MT\_MAX\_LKEYS}      & 511   & Max keys per leaf ($2^9 - 1$) \\
\code{MT\_MIN\_LKEYS}      & 255   & Min keys per leaf ($\floor{511/2}$) \\
\code{MT\_MAX\_HEIGHT}     & 32    & Maximum tree height (stack depth) \\
\code{MT\_KEY\_MAX}         & $2^{31}-1$ & Sentinel value (\code{INT32\_MAX}) \\
\bottomrule
\end{tabular}
\end{table}


% ══════════════════════════════════════════════════════════════════
\section{Summary}
\label{sec:summary}

The matryoshka tree provides a practical middle ground between static
SIMD-optimised indexes (FAST) and traditional pointer-based
B\textsuperscript{+} trees.  By confining FAST-style hierarchical
blocking to within each page-sized leaf node and connecting nodes via
standard B\textsuperscript{+} tree pointers, it achieves:

\begin{enumerate}[nosep]
  \item SIMD-parallel intra-node search with $\ceil{\dn/\dk}$ comparisons
    per leaf;
  \item $\Oh(B \cdot \log_B n)$ insertion and deletion via node-local
    rebuilds and standard B\textsuperscript{+} splits/merges;
  \item Efficient range scans via a doubly-linked leaf chain; and
  \item Cache-friendly memory layout with page-aligned nodes and
    contiguous blocked key arrays.
\end{enumerate}

The nested architecture---SIMD blocks inside cache-line blocks inside
B\textsuperscript{+} nodes---mirrors the memory hierarchy itself,
giving the structure its name: like a matryoshka doll, each level
contains a smaller, self-similar structure within.


% ══════════════════════════════════════════════════════════════════
\begin{thebibliography}{99}

\bibitem{bayer1972organization}
R.~Bayer and E.~McCreight.
\newblock Organization and maintenance of large ordered indexes.
\newblock \emph{Acta Informatica}, 1(3):173--189, 1972.

\bibitem{comer1979ubiquitous}
D.~Comer.
\newblock The ubiquitous {B}-tree.
\newblock \emph{ACM Computing Surveys}, 11(2):121--137, 1979.

\bibitem{graefe2011modern}
G.~Graefe.
\newblock Modern {B}-tree techniques.
\newblock \emph{Foundations and Trends in Databases}, 3(4):203--402, 2011.

\bibitem{hankins2003effect}
R.~A. Hankins and J.~M. Patel.
\newblock Effect of node size on the performance of cache-conscious
  {B}\textsuperscript{+}-trees.
\newblock In \emph{Proc.\ ACM SIGMETRICS}, pages 283--294, 2003.

\bibitem{kim2010fast}
C.~Kim, J.~Chhugani, N.~Satish, E.~Sedlar, A.~D. Nguyen, T.~Kaldewey,
  V.~W. Lee, S.~A. Brandt, and P.~Dubey.
\newblock {FAST}: {Fast} architecture sensitive tree search on modern {CPUs}
  and {GPUs}.
\newblock In \emph{Proc.\ ACM SIGMOD}, pages 339--350, 2010.

\bibitem{lehman1981efficient}
P.~L. Lehman and S.~B. Yao.
\newblock Efficient locking for concurrent operations on {B}-trees.
\newblock \emph{ACM Trans.\ Database Systems}, 6(4):650--670, 1981.

\bibitem{leis2013adaptive}
V.~Leis, A.~Kemper, and T.~Neumann.
\newblock The adaptive radix tree: {ARTful} indexing for main-memory databases.
\newblock In \emph{Proc.\ IEEE ICDE}, pages 38--49, 2013.

\bibitem{mao2012cache}
Y.~Mao, E.~Kohler, and R.~T. Morris.
\newblock Cache craftiness for fast multicore key-value storage.
\newblock In \emph{Proc.\ ACM EuroSys}, pages 183--196, 2012.

\bibitem{rao1999cache}
J.~Rao and K.~A. Ross.
\newblock Cache conscious indexing for decision-support in main memory.
\newblock In \emph{Proc.\ VLDB}, pages 78--89, 1999.

\bibitem{rao2000making}
J.~Rao and K.~A. Ross.
\newblock Making {B}\textsuperscript{+}-trees cache conscious in main memory.
\newblock In \emph{Proc.\ ACM SIGMOD}, pages 475--486, 2000.

\bibitem{schlegel2009kary}
B.~Schlegel, R.~Gemulla, and W.~Lehner.
\newblock {K}-ary search on modern processors.
\newblock In \emph{Proc.\ DaMoN Workshop}, pages 52--60, 2009.

\bibitem{zhou2002implementing}
J.~Zhou and K.~A. Ross.
\newblock Implementing database operations using {SIMD} instructions.
\newblock In \emph{Proc.\ ACM SIGMOD}, pages 145--156, 2002.

\end{thebibliography}

\end{document}
