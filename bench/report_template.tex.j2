%% report_template.tex.j2 -- Jinja2 LaTeX template for the matryoshka
%% comparative benchmark report.
%%
%% Custom Jinja2 delimiters for LaTeX compatibility:
%%   BLOCK, VAR, and comment delimiters with backslash prefix.
%%
\documentclass[11pt,a4paper]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage[colorlinks=true,linkcolor=matryoshkacolor,urlcolor=matryoshkacolor,citecolor=matryoshkacolor]{hyperref}
\usepackage{fancyhdr}
\usepackage{siunitx}
\usepackage[table]{xcolor}
\usepackage{longtable}
\usepackage{float}
\usepackage{enumitem}
\usepackage{microtype}
\usepackage{listings}
\usepackage{caption}
\usepackage{colortbl}

%% ── Colours ─────────────────────────────────────────────────────────────────
\definecolor{matryoshkacolor}{RGB}{31,119,180}
\definecolor{stdsetcolor}{RGB}{214,39,40}
\definecolor{tlxcolor}{RGB}{148,103,189}
\definecolor{artcolor}{RGB}{255,127,14}
\definecolor{abseilcolor}{RGB}{44,160,44}
\definecolor{rowhl}{RGB}{220,230,242}

%% ── Page style ──────────────────────────────────────────────────────────────
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Matryoshka B+ Tree Benchmark Report}
\fancyhead[R]{\small \VAR{date}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\lstset{basicstyle=\ttfamily\small, breaklines=true, frame=single, columns=fullflexible}
\sisetup{group-separator={,}, group-minimum-digits=4}

\begin{document}

%% ═══════════════════════════════════ Title Page ═════════════════════════════
\begin{titlepage}
\centering
\vspace*{3cm}
{\Huge\bfseries Matryoshka B+ Tree:\\[0.3em]
Insert/Delete Performance Report\par}
\vspace{1.5cm}
{\Large Comparative Benchmark Results\par}
\vspace{2cm}
{\large \VAR{date}\par}
\vspace{3cm}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
CPU       & \VAR{sysinfo.cpu} \\
L1d Cache & \VAR{sysinfo.l1d} \\
L2 Cache  & \VAR{sysinfo.l2} \\
L3 Cache  & \VAR{sysinfo.l3} \\
Kernel    & \VAR{sysinfo.kernel} \\
Page Size & \VAR{sysinfo.page_size} \\
\bottomrule
\end{tabular}
\vfill
{\small Generated by \texttt{bench\_compare} --- matryoshka project\par}
\end{titlepage}

%% ═══════════════════════════════════ TOC ════════════════════════════════════
\tableofcontents
\newpage

%% ═══════════════════════════════════ Introduction ══════════════════════════
\section{Introduction}

This report evaluates the \textcolor{matryoshkacolor}{\textbf{matryoshka}}
B+ tree --- a SIMD-blocked B+ tree using the FAST hierarchical layout
(Kim et~al., 2010) --- against several tree and ordered-map libraries on
\emph{insert-heavy} and \emph{delete-heavy} workloads.  Goals:
\begin{enumerate}[nosep]
  \item Quantify the modification throughput gap across dataset sizes
        (\num{65536} to \num{16777216} keys).
  \item Identify micro-architectural bottlenecks (cache misses, TLB
        pressure, branch misprediction) that explain the differences.
\end{enumerate}
All measurements use \texttt{clock\_gettime(CLOCK\_MONOTONIC)}.  Results
are reported as \si{Mop/s} and \si{ns/op}.

%% ═══════════════════════════════════ Libraries ═════════════════════════════
\section{Library Descriptions}

\begin{table}[H]
\centering
\caption{Libraries under test.}
\label{tab:libraries}
\begin{tabular}{lll}
\toprule
\textbf{Name} & \textbf{Label} & \textbf{Description} \\
\midrule
\BLOCK{for lib in libraries}
\texttt{\VAR{lib.name}} & \VAR{lib.label} & \VAR{lib.description} \\
\BLOCK{endfor}
\bottomrule
\end{tabular}
\end{table}

%% ═══════════════════════════════════ Workloads ═════════════════════════════
\section{Workload Descriptions}

\begin{table}[H]
\centering
\caption{Benchmark workloads.}
\label{tab:workloads}
\begin{tabular}{lp{10cm}}
\toprule
\textbf{Workload} & \textbf{Description} \\
\midrule
\texttt{seq\_insert}
  & Insert $N$ keys in ascending order. Exercises append paths. \\
\texttt{rand\_insert}
  & Insert $N$ unique keys in random order. Stresses leaf splits. \\
\texttt{ycsb\_a}
  & 95\% insert / 5\% search. Write-dominated OLTP model. \\
\texttt{rand\_delete}
  & Bulk-load $N$ sorted keys, delete all in random order. \\
\texttt{mixed}
  & Bulk-load $N$ keys, then $N$ alternating insert/delete ops. \\
\texttt{ycsb\_b}
  & Bulk-load $N$ keys, then 50\% delete / 50\% search. \\
\texttt{search\_after\_churn}
  & Bulk-load $N$ keys, $N/2$ mixed churn (untimed), then
    \num{5000000} random predecessor searches. \\
\bottomrule
\end{tabular}
\end{table}

%% ═══════════════════════════════════ Insert-Heavy Results ══════════════════
\section{Results: Insert-Heavy Workloads}

\subsection{Sequential Insert}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_seq_insert}}
\caption{Sequential insert throughput (Mop/s).}
\label{fig:bar_seq_insert}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_seq_insert}}
\caption{Sequential insert scaling.}
\label{fig:scale_seq_insert}
\end{figure}

\subsection{Random Insert}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_rand_insert}}
\caption{Random insert throughput (Mop/s).}
\label{fig:bar_rand_insert}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_rand_insert}}
\caption{Random insert scaling.}
\label{fig:scale_rand_insert}
\end{figure}

\subsection{YCSB-A (95\% Insert / 5\% Search)}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_ycsb_a}}
\caption{YCSB-A throughput (Mop/s).}
\label{fig:bar_ycsb_a}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_ycsb_a}}
\caption{YCSB-A scaling.}
\label{fig:scale_ycsb_a}
\end{figure}

%% ═══════════════════════════════════ Delete-Heavy Results ══════════════════
\section{Results: Delete-Heavy Workloads}

\subsection{Random Delete}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_rand_delete}}
\caption{Random delete throughput (Mop/s).}
\label{fig:bar_rand_delete}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_rand_delete}}
\caption{Random delete scaling.}
\label{fig:scale_rand_delete}
\end{figure}

\subsection{Mixed Insert/Delete}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_mixed}}
\caption{Mixed insert/delete throughput (Mop/s).}
\label{fig:bar_mixed}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_mixed}}
\caption{Mixed insert/delete scaling.}
\label{fig:scale_mixed}
\end{figure}

\subsection{YCSB-B (50\% Delete / 50\% Search)}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_ycsb_b}}
\caption{YCSB-B throughput (Mop/s).}
\label{fig:bar_ycsb_b}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_ycsb_b}}
\caption{YCSB-B scaling.}
\label{fig:scale_ycsb_b}
\end{figure}

%% ═══════════════════════════════════ Search After Churn ════════════════════
\section{Results: Search After Churn}

The \texttt{search\_after\_churn} workload isolates FAST's search
advantage from its modification penalty by measuring pure search
throughput on a tree that has undergone insert/delete churn.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_bar_search_after_churn}}
\caption{Search throughput after churn (Mop/s).}
\label{fig:bar_search_after_churn}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_scale_search_after_churn}}
\caption{Search-after-churn scaling.}
\label{fig:scale_search_after_churn}
\end{figure}

%% ═══════════════════════════════════ Hardware Counters ═════════════════════
\section{Hardware Counter Analysis}

\BLOCK{if chart_perf}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\VAR{chart_perf}}
\caption{Hardware counters: dTLB miss rate, LLC miss rate, IPC,
         branch misprediction rate.}
\label{fig:perf_counters}
\end{figure}
\BLOCK{endif}

\subsection{dTLB Miss Rate}
Matryoshka's arena allocator places leaf nodes in contiguous 2\,MiB
superpage-aligned regions.  At $N = \num{\VAR{largest_n}}$, matryoshka's
dTLB miss rate is \VAR{matryoshka_dtlb_miss_rate} per \num{1000} ops,
versus \VAR{stdset_dtlb_miss_rate} for \texttt{std::set}.  Red-black
tree pointer chasing touches a new TLB entry per level; matryoshka
confines each leaf search to a single 4\,KiB page.

\subsection{LLC Miss Rate}
Matryoshka packs up to 511 keys per 4\,KiB page ($\lceil N/511 \rceil$
pages at the leaf level).  \texttt{std::set} requires one 40--48\,B heap
node per key.  At $N = \num{\VAR{largest_n}}$: \VAR{matryoshka_llc_miss_rate}
LLC misses/\num{1000}\,ops (matryoshka) vs.\ \VAR{stdset_llc_miss_rate}
(\texttt{std::set}).

\subsection{IPC}
SIMD leaf search achieves IPC of \VAR{matryoshka_ipc} via pipelined
\texttt{\_mm\_cmpgt\_epi32}/\texttt{\_mm\_movemask\_ps} without
data-dependent branches.  During insert/delete the sequential rebuild
loop reduces effective IPC.

\subsection{Branch Misprediction}
FAST replaces conditional branches with SIMD mask arithmetic, yielding
near-zero misprediction during search.  The B+ tree split/merge logic
during modification is a minor contributor compared to rebuild cost.

%% ═══════════════════════════════════ Profiling ═════════════════════════════
\section{Profiling: Hot Functions}

\begin{table}[H]
\centering
\caption{Top functions (\texttt{perf record}, rand\_insert, $N{=}\num{1048576}$).}
\label{tab:profile}
\begin{tabular}{rll}
\toprule
\textbf{\% Overhead} & \textbf{Function} & \textbf{Source} \\
\midrule
\BLOCK{for fn in profile_functions}
\num{\VAR{fn.overhead}}\% & \texttt{\VAR{fn.name}} & \texttt{\VAR{fn.source}} \\
\BLOCK{endfor}
\bottomrule
\end{tabular}
\end{table}

The profile confirms that \texttt{mt\_leaf\_build} and
\texttt{mt\_leaf\_extract\_sorted} dominate: each insert extracts all
$\le 511$ keys from the FAST blocked layout, inserts one key, and
rebuilds the entire hierarchical layout from scratch.

%% ═══════════════════════════════════ Results Table ═════════════════════════
\section{Detailed Results Table}

Matryoshka rows highlighted in \colorbox{rowhl}{blue}.

\begin{longtable}{llrS[table-format=4.2]S[table-format=6.1]}
\caption{Full benchmark results.\label{tab:results}} \\
\toprule
\textbf{Library} & \textbf{Workload} & \textbf{N} &
  {\textbf{Mop/s}} & {\textbf{ns/op}} \\
\midrule
\endfirsthead
\caption[]{Full benchmark results (continued).} \\
\toprule
\textbf{Library} & \textbf{Workload} & \textbf{N} &
  {\textbf{Mop/s}} & {\textbf{ns/op}} \\
\midrule
\endhead
\midrule
\multicolumn{5}{r}{\emph{Continued on next page}} \\
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\BLOCK{for r in results}
\BLOCK{if r.library == 'matryoshka'}
\rowcolor{rowhl}
\BLOCK{endif}
\texttt{\VAR{r.library}} & \texttt{\VAR{r.workload}} &
  \num{\VAR{r.n}} & \VAR{r.mops} & \VAR{r.ns_per_op} \\
\BLOCK{endfor}
\end{longtable}

%% ═══════════════════════════════════ Analysis ══════════════════════════════
\section{Analysis and Diagnosis}

\subsection{The O(B) Leaf Rebuild Cost}

The dominant cost is the \emph{full leaf rebuild}.  Unlike a sorted-array
B-tree leaf (where insert is a \texttt{memmove} of $\sim B/2$ keys),
matryoshka must:
\begin{enumerate}[nosep]
  \item \textbf{Extract} all $\le 511$ keys from the FAST layout via
        \texttt{mt\_leaf\_extract\_sorted} (iterates \num{512} slots,
        dereferences \texttt{sorted\_rank[]}).
  \item \textbf{Insert/remove} the target key (binary search +
        \texttt{memmove}).
  \item \textbf{Rebuild} the full FAST layout via \texttt{mt\_leaf\_build}:
        BFS tree, in-order map, recursive hierarchical blocked layout.
\end{enumerate}
This is ${\sim}3 \times 511 \approx \num{1533}$ key touches per insert vs.\
${\sim}255$ for a sorted-array leaf.  \texttt{mt\_leaf\_build} consumes
\VAR{pct_leaf_build}\% of CPU during random insert at $N{=}\num{1048576}$.

Matryoshka achieves \VAR{matryoshka_rand_insert_mops} Mop/s on random
insert ($N{=}\num{1048576}$), vs.\ \VAR{stdset_rand_insert_mops} Mop/s
(\texttt{std::set}) and \VAR{best_competitor_rand_insert_mops} Mop/s
(fastest B-tree competitor).

\subsection{SIMD Blocking: Search Benefit, Zero Modification Benefit}

The FAST layout delivers ${\sim}4.5\times$ fewer comparisons per search
than linear scan, using \texttt{\_mm\_cmpgt\_epi32} +
\texttt{\_mm\_movemask\_ps} to resolve 3 keys per step.  This yields
\VAR{matryoshka_search_mops} Mop/s on \texttt{search\_after\_churn}
($N{=}\num{1048576}$), fastest among all libraries.

However, SIMD provides \emph{zero benefit} during modification: the
insert/delete path unconditionally extracts and rebuilds without
performing any SIMD search within the modified leaf.

\subsection{Arena Allocator and TLB Effects}

The arena allocator places leaves in superpage-aligned regions:
\begin{itemize}[nosep]
  \item \textbf{Reduced dTLB misses}: one 2\,MiB superpage covers 512
        leaf pages.  dTLB rate: \VAR{matryoshka_dtlb_miss_rate}/\num{1000}
        ops vs.\ \VAR{stdset_dtlb_miss_rate} for \texttt{std::set}.
  \item \textbf{Prefetch}: contiguous pages benefit sequential scans.
\end{itemize}
During insert/delete, TLB effects are secondary to the $O(B)$ rebuild cost.

\subsection{Where std::set Falls Behind}

\texttt{std::set} (red-black tree) suffers from pointer chasing (one
cache miss per level), poor spatial locality, and high per-node overhead
(40--48\,B/key vs.\ 4\,B in matryoshka).  Despite this, its $O(\log N)$
insert with a constant-factor pointer update often beats matryoshka's
$O(B)$ rebuild when $B$ is large.

\subsection{Where TLX and Abseil Compete}

Both use sorted-array B-tree leaves with \texttt{memmove} insert ($B
\approx 64$--$256$).  They stay within \VAR{btree_insert_gap_pct}\% of
each other and consistently outperform matryoshka on modification because
their per-insert constant factor is far lower.  Neither uses SIMD for
in-leaf search.

\subsection{ART's Radix Approach}

ART performs $O(\text{key\_length})$ operations independent of $N$.  For
4-byte keys it traverses $\le 4$ levels with compact node arrays (4--256
entries).  Insert and delete are cache-efficient, but ART lacks native
predecessor search, so \texttt{search\_after\_churn} uses point lookups.

\subsection{Overall Diagnosis}

Matryoshka trades modification throughput for search throughput.  The
FAST layout minimises cache misses and branch mispredictions during
search, but the $O(B)$ extract-and-rebuild per insert/delete makes it
\VAR{insert_slowdown_factor}$\times$ slower on insert-heavy and
\VAR{delete_slowdown_factor}$\times$ slower on delete-heavy workloads
than the best B-tree competitor.  This trade-off is inherent: the
hierarchical blocking that accelerates search makes in-place modification
impossible.

%% ═══════════════════════════════════ Recommendations ═══════════════════════
\section{Improvement Recommendations}

\subsection{Incremental Leaf Update}

Avoid full rebuild for single-key changes.  Compute the incremental BFS
change and rewrite only the $O(\log B)$ affected SIMD/cache-line blocks
and their \texttt{sorted\_rank[]} entries.  Expected $3$--$5\times$
speedup for single-key ops.

\subsection{Batch Insert API}

Provide \texttt{matryoshka\_insert\_batch(tree, keys, k)}: sort incoming
keys, merge into each affected leaf's sorted array, rebuild once per
leaf.  Amortises cost from $k \times O(B)$ to $O(B + k \log k)$.  Batch
sizes of 32--64 reduce per-key cost by $20$--$50\times$.

\subsection{Write-Optimised Leaf Variant}

Dual-mode leaf:
\begin{itemize}[nosep]
  \item \textbf{Sorted-array mode} for small/frequently modified leaves:
        \texttt{memmove} insert, SIMD binary search (no blocking).
  \item \textbf{FAST mode} for large/read-heavy leaves: current
        hierarchical layout, activated after $T$ searches without
        modification or at a size threshold.
\end{itemize}
Transition uses existing \texttt{mt\_leaf\_build} /
\texttt{mt\_leaf\_extract\_sorted}.

\subsection{Superpage Hierarchy for Large Datasets}

Use 2\,MiB superpage leaves (\texttt{mt\_hierarchy\_init\_superpage})
holding ${\sim}\num{131071}$ keys (depth~17).  Reduces leaf-level TLB
entries by $512\times$.  Requires batch insert to amortise the larger
per-leaf rebuild.

%% ═══════════════════════════════════ References ════════════════════════════
\section*{References}
\addcontentsline{toc}{section}{References}

\begin{enumerate}[label={[\arabic*]}, nosep, leftmargin=2em]
  \item \label{ref:fast}
        C.~Kim, J.~Chhugani, N.~Satish, E.~Sedlar, A.~D.~Nguyen,
        T.~Kaldewey, V.~W.~Lee, S.~A.~Brandt, and P.~Dubey.
        \emph{FAST: Fast Architecture Sensitive Tree Search on Modern
        CPUs and GPUs.}  SIGMOD~'10, pp.~339--350, 2010.
  \item \label{ref:btree}
        R.~Bayer and E.~McCreight.
        \emph{Organization and Maintenance of Large Ordered Indexes.}
        Acta Informatica, 1(3):173--189, 1972.
  \item \label{ref:art}
        V.~Leis, A.~Kemper, and T.~Neumann.
        \emph{The Adaptive Radix Tree: ARTful Indexing for Main-Memory
        Databases.}  ICDE~'13, pp.~38--49, 2013.
  \item \label{ref:cssbtree}
        J.~Rao and K.~A.~Ross.
        \emph{Making B+-Trees Cache Conscious in Main Memory.}
        SIGMOD~'00, pp.~475--486, 2000.
\end{enumerate}

\end{document}
